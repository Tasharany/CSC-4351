package Parse;
import java.util.ArrayList;
import ErrorMsg.ErrorMsg;
import Absyn.*;

parser code {:
    public ErrorMsg errorMsg;
    Lexer lexer;

    public void syntax_error(java_cup.runtime.Symbol current) {
        report_error("Syntax error (" + current.sym + ")", current);
    }

    public void report_error(String message, java_cup.runtime.Symbol info) {
        errorMsg.error(info.left, message);
    }

    public Grm(Lexer l, ErrorMsg e) {
        this();
        errorMsg = e;
        lexer = l;
    }
:};

action code {:
    static Symbol.Symbol sym(String s) {
        return Symbol.Symbol.symbol(s);
    }
:};

scan with {: return lexer.nextToken(); :};

/* Terminals */
terminal String ID, STRING_LITERAL;
terminal Integer DECIMAL_LITERAL;
terminal Character CHAR_LITERAL;
terminal VAR, FUN, TYPEDEF, STRUCT, UNION, ENUM;
terminal CONST, VOLATILE, EXTERN, STATIC, AUTO, REGISTER;
terminal VOID, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal EQ, NEQ, LT, LE, GT, GE;
terminal AND, OR, NOT;
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK;
terminal SEMICOLON, COMMA, ASSIGN, COLON;
terminal IF, ELSE, WHILE, DO, FOR, BREAK, CONTINUE, RETURN;


/* Non terminals */
non terminal Declaration            declaration;
non terminal ArrayList<Declaration> declaratitron_list;
non terminal BitfieldValue         bitfield_value;
non terminal ArrayList<BitfieldValue> bitfield_list;
non terminal Type                  type;
non terminal Name                  name;
non terminal CompoundStmt          compound_statement;
non terminal ArrayList<Parameter>  parameter_list;
non terminal ArrayList<Type>       type_parameters;

/* Precedence declarations */
precedence nonassoc ELSE;
precedence nonassoc ASSIGN;
precedence left EQ, NEQ;
precedence left LT, LE, GT, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence right NOT;

/* Grammar rules */
start with declaration_list;

declaration_list ::=
    declaration:d
    {: ArrayList<Declaration> list = new ArrayList<>();
       list.add(d);
       RESULT = list; :}
  | declaration_list:dl declaration:d
    {: dl.add(d);
       RESULT = dl; :}
  ;
declaration ::=
    VAR name:n SEMICOLON
    {: RESULT = new VarDec(VARleft, null, n); :}
  ;
declaration ::=
    VAR bitfield_list:b type:t name:n SEMICOLON
    {: RESULT = new Declaration(VARleft, Declaration.VAR_DEC, b, t, n, null); :}
  | FUN bitfield_list:b type:t name:n LPAREN parameter_list:p RPAREN compound_statement:c
    {: RESULT = new Declaration(FUNleft, Declaration.FUN_DEC, b, t, n, new FunDec.Body(p, c)); :}
  ;

bitfield_list ::=
    /* empty */
    {: RESULT = new ArrayList<>(); :}
  | bitfield_value:b bitfield_list:bl
    {: bl.add(0, b);
       RESULT = bl; :}
  ;

bitfield_value ::=
    CONST    {: RESULT = new BitfieldValue(CONSTleft, BitfieldValue.CONST); :}
  | VOLATILE {: RESULT = new BitfieldValue(VOLATILEleft, BitfieldValue.VOLATILE); :}
  | EXTERN   {: RESULT = new BitfieldValue(EXTERNleft, BitfieldValue.EXTERN); :}
  | STATIC   {: RESULT = new BitfieldValue(STATICleft, BitfieldValue.STATIC); :}
  | AUTO     {: RESULT = new BitfieldValue(AUTOleft, BitfieldValue.AUTO); :}
  | REGISTER {: RESULT = new BitfieldValue(REGISTERleft, BitfieldValue.REGISTER); :}
  ;

type ::=
    VOID   {: RESULT = new Type(VOIDleft, Type.VOID); :}
  | CHAR   {: RESULT = new Type(CHARleft, Type.CHAR); :}
  | SHORT  {: RESULT = new Type(SHORTleft, Type.SHORT); :}
  | INT    {: RESULT = new Type(INTleft, Type.INT); :}
  | LONG   {: RESULT = new Type(LONGleft, Type.LONG); :}
  | FLOAT  {: RESULT = new Type(FLOATleft, Type.FLOAT); :}
  | DOUBLE {: RESULT = new Type(DOUBLEleft, Type.DOUBLE); :}
  | ID:i   {: RESULT = new Type(ileft, Type.NAMED, sym(i)); :}
  ;

name ::=
    ID:i {: RESULT = new Name(ileft, sym(i)); :}
  ;

parameter_list ::=
    /* empty */
    {: RESULT = new ArrayList<>(); :}
  | type:t name:n
    {: ArrayList<Parameter> list = new ArrayList<>();
       list.add(new Parameter(tleft, t, n));
       RESULT = list; :}
  | parameter_list:pl COMMA type:t name:n
    {: pl.add(new Parameter(tleft, t, n));
       RESULT = pl; :}
  ;
