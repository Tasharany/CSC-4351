package Parse;
import java.util.ArrayList;
import ErrorMsg.ErrorMsg;
import Absyn.*;

parser code {:
    public ErrorMsg errorMsg;

    public void syntax_error(java_cup.runtime.Symbol current) {
        errorMsg.error(current.left, "Syntax error");
    }

    public Grm(Lexer l, ErrorMsg e) {
        this();
        lexer = l;
        errorMsg = e;
    }
:};

action code {:
    static Symbol.Symbol sym(String s) {
        return Symbol.Symbol.symbol(s);
    }
:};

scan with {: return lexer.nextToken(); :};

/* Terminals */
terminal String ID, STRING_LITERAL;
terminal Integer DECIMAL_LITERAL;
terminal Character CHAR_LITERAL;
terminal Integer NUMBER;
terminal SHORT, TIMES, GT, ARROW, DIVASSIGN;
terminal CONST, GE, PERIOD, REGISTER, ENUM;
terminal RBRACK, SIZEOF, COMMA, RBRACE, RPAREN;
terminal LBRACK, LT, INCREMENT, SUBASSIGN, DOUBLE;
terminal BWISEANDASSIGN, STRUCT, LBRACE, LPAREN, MODASSIGN;
terminal TILDE, LE, VAR, BITWISEAND, FLOAT;
terminal GOTO, EQ, LSHIFTASSIGN, MODULUS, LONG;
terminal PLUS, DIVIDE, WHILE, UNION, ASSIGN;
terminal CHAR, ADDASSIGN, DO, FOR, VOID;
terminal EXTERN, RETURN, ELSE, BREAK, FUN;
terminal INT, SEMICOLON, ELIPSES;
terminal MULASSIGN, DECREMENT, MINUS, OR;
terminal CONTINUE, IF, BWISEOR;
terminal COLON, BWISEXOR, BWISEORASSIGN, RSHIFTASSIGN, VOLATILE;
terminal RSHIFT, BWISEXORASSIGN, NEQ, AND;
terminal STATIC, LSHIFT, TYPEDEF, AUTO;
terminal EOF;
terminal error;



/* Non-terminals */
non terminal Declaration declaration;
non terminal ArrayList<Declaration> declaration_list;
non terminal ArrayList<BitfieldValue> bitfield_list;
non terminal BitfieldValue bitfield_value;
non terminal Type type;
non terminal TypeName type_name;
non terminal Exp exp, ae, be;  // arithmetic and boolean expressions
non terminal ArrayList<Parameter> parameter_list;
non terminal ArrayList<Type> type_parameters;
non terminal Name name;
non terminal Var;

/* Precedence declarations */
precedence left OR;
precedence left AND;
precedence left EQ, NEQ;
precedence left LT, LE, GT, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left UMINUS;

/* Start with declarations */
start with declaration_list;

/* Grammar Rules */
declaration_list ::=
    declaration:d
    {: ArrayList<Declaration> list = new ArrayList<>();
       list.add(d);
       RESULT = list; :}
  | declaration_list:dl declaration:d
    {: dl.add(d);
       RESULT = dl; :}
  ;

declaration ::=
    VAR bitfield_list:b type:t name:n ASSIGN exp:e SEMICOLON
    {: RESULT = new VarDec(VARleft, b, t, n, e); :}
  | FUN bitfield_list:b type:t name:n parameter_list:p LBRACE exp:e RBRACE
    {: RESULT = new FunDec(FUNleft, b, t, n, p, e); :}
  ;

exp ::=
    ae:a
    {: RESULT = a; :}
  | be:b
    {: RESULT = b; :}
  ;

ae ::=
    ae:a PLUS ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.PLUS, b); :}
  | ae:a MINUS ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.MINUS, b); :}
  | ae:a TIMES ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.TIMES, b); :}
  | ae:a DIVIDE ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.DIVIDE, b); :}
  | MINUS ae:a                                    %prec UMINUS
    {: RESULT = new OpExp(MINUSleft, a, OpExp.UMINUS, null); :}
  | LPAREN ae:a RPAREN
    {: RESULT = a; :}
  | ID:i
    {: RESULT = new IdExp(ileft, sym(i)); :}
  | DECIMAL_LITERAL:n
    {: RESULT = new IntExp(nleft, n); :}
  ;

be ::=
    be:a AND be:b
    {: RESULT = new OpExp(aleft, a, OpExp.AND, b); :}
  | be:a OR be:b
    {: RESULT = new OpExp(aleft, a, OpExp.OR, b); :}
  | ae:a EQ ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.EQ, b); :}
  | ae:a NEQ ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.NEQ, b); :}
  | ae:a LT ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.LT, b); :}
  | ae:a LE ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.LE, b); :}
  | ae:a GT ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.GT, b); :}
  | ae:a GE ae:b
    {: RESULT = new OpExp(aleft, a, OpExp.GE, b); :}
  | LPAREN be:a RPAREN
    {: RESULT = a; :}

  /* Start symbol */
  start with Exp;

  /* Grammar rules */
  Exp ::=
      error:e
      {: RESULT = new SeqExp(eleft, null); :}
    | Var:v
      {: RESULT = new VarExp(vleft, v); :}
    ;

  Var ::=
      ID:i
      {: RESULT = new SimpleVar(ileft, sym(i)); :}
    ;

