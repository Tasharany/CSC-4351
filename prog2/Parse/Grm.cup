package Parse;
import java.util.ArrayList;
import ErrorMsg.ErrorMsg;
import Absyn.*;

parser code {:
    public ErrorMsg errorMsg;
    Lexer lexer;

    public void syntax_error(java_cup.runtime.Symbol current) {
        report_error("Syntax error (" + current.sym + ")", current);
    }

    public void report_error(String message, java_cup.runtime.Symbol info) {
        errorMsg.error(info.left, message);
    }

    public Grm(Lexer l, ErrorMsg e) {
        this();
        errorMsg = e;
        lexer = l;
    }
:};

action code {:
    static Symbol.Symbol sym(String s) {
        return Symbol.Symbol.symbol(s);
    }
:};

scan with {: return lexer.nextToken(); :};

/* Terminals */
terminal String ID, STRING_LITERAL;
terminal Integer DECIMAL_LITERAL;
terminal char CHAR_LITERAL;
terminal INT, COMMA, COLON, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK;
terminal LBRACE, RBRACE, PLUS, MINUS, TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE;
terminal AND, OR, ASSIGN, IF, ELSE, WHILE, FOR, DO, BREAK, FUN, VAR;
terminal VOLATILE, NOT, REGISTER, CONTINUE, TYPEDEF, STRUCT, STATIC, SIZEOF;
terminal RETURN, EXTERN, DOUBLE, UNION, SHORT, FLOAT, CONST, VOID, LONG;
terminal GOTO, ENUM, CHAR, AUTO, RSHIFTASSIGN, LSHIFTASSIGN, ELIPSES;
terminal BWISEORASSIGN, BWISEXORASSIGN, RSHIFT, LSHIFT, DIVASSIGN, ARROW;
terminal SUBASSIGN, DECREMENT, ADDASSIGN, INCREMENT, MULASSIGN;
terminal BWISEANDASSIGN, MODASSIGN, TILDE, BWISEOR, BWISEXOR, PERIOD;
terminal BITWISEAND, MODULUS;
/* Precedence declarations */
precedence left OR;
precedence left AND;
precedence left BWISEOR;
precedence left BWISEXOR;
precedence left BITWISEAND;
precedence nonassoc EQ, NEQ;
precedence nonassoc LT, LE, GT, GE;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULUS;
precedence right TILDE, NOT;



/* Non terminals */
non terminal Declaration            declaration;
non terminal ArrayList<Declaration> declaratitron_list;
non terminal BitfieldValue         bitfield_value;
non terminal ArrayList<BitfieldValue> bitfield_list;
non terminal Type                  type;
non terminal Name                  name;
non terminal CompoundStmt          compound_statement;
non terminal ArrayList<Parameter>  parameter_list;
non terminal ArrayList<Type>       type_parameters;
non terminal Exp exp;
non terminal Var var;

/* Grammar rules */
start with exp;

exp ::=
    VAR ID:i
    {: RESULT = new VarExp(VARleft, new SimpleVar(ileft, sym(i))); :}
  | error
    {: RESULT = new SeqExp(errorleft, null); :}
  ;

declaration_list ::=
    declaration:d
    {: ArrayList<Declaration> list = new ArrayList<>();
       list.add(d);
       RESULT = list; :}
  | declaration_list:dl declaration:d
    {: dl.add(d);
       RESULT = dl; :}
  ;
declaration ::=
    VAR name:n SEMICOLON
    {: RESULT = new VarDec(VARleft, null, n); :}
  ;
declaration ::=
    VAR bitfield_list:b type:t name:n SEMICOLON
    {: RESULT = new Declaration(VARleft, Declaration.VAR_DEC, b, t, n, null); :}
  | FUN bitfield_list:b type:t name:n LPAREN parameter_list:p RPAREN compound_statement:c
    {: RESULT = new Declaration(FUNleft, Declaration.FUN_DEC, b, t, n, new FunDec.Body(p, c)); :}
  ;

bitfield_list ::=
    /* empty */
    {: RESULT = new ArrayList<>(); :}
  | bitfield_value:b bitfield_list:bl
    {: bl.add(0, b);
       RESULT = bl; :}
  ;

bitfield_value ::=
    CONST    {: RESULT = new BitfieldValue(CONSTleft, BitfieldValue.CONST); :}
  | VOLATILE {: RESULT = new BitfieldValue(VOLATILEleft, BitfieldValue.VOLATILE); :}
  | EXTERN   {: RESULT = new BitfieldValue(EXTERNleft, BitfieldValue.EXTERN); :}
  | STATIC   {: RESULT = new BitfieldValue(STATICleft, BitfieldValue.STATIC); :}
  | AUTO     {: RESULT = new BitfieldValue(AUTOleft, BitfieldValue.AUTO); :}
  | REGISTER {: RESULT = new BitfieldValue(REGISTERleft, BitfieldValue.REGISTER); :}
  ;

type ::=
    VOID   {: RESULT = new Type(VOIDleft, Type.VOID); :}
  | CHAR   {: RESULT = new Type(CHARleft, Type.CHAR); :}
  | SHORT  {: RESULT = new Type(SHORTleft, Type.SHORT); :}
  | INT    {: RESULT = new Type(INTleft, Type.INT); :}
  | LONG   {: RESULT = new Type(LONGleft, Type.LONG); :}
  | FLOAT  {: RESULT = new Type(FLOATleft, Type.FLOAT); :}
  | DOUBLE {: RESULT = new Type(DOUBLEleft, Type.DOUBLE); :}
  | ID:i   {: RESULT = new Type(ileft, Type.NAMED, sym(i)); :}
  ;

name ::=
    ID:i {: RESULT = new Name(ileft, sym(i)); :}
  ;

parameter_list ::=
    /* empty */
    {: RESULT = new ArrayList<>(); :}
  | type:t name:n
    {: ArrayList<Parameter> list = new ArrayList<>();
       list.add(new Parameter(tleft, t, n));
       RESULT = list; :}
  | parameter_list:pl COMMA type:t name:n
    {: pl.add(new Parameter(tleft, t, n));
       RESULT = pl; :}
  ;
