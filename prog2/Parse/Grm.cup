package Parse;
import java.util.ArrayList;

action code {:
    static Symbol.Symbol sym(String s) {
        return Symbol.Symbol.symbol(s);
    }
:};

parser code  {:
    Lexer lexer;

    public void syntax_error(java_cup.runtime.Symbol current) {
        report_error("Syntax error (" + current.sym + ")", current);
    }

    ErrorMsg.ErrorMsg errorMsg;

    public void report_error(String message, java_cup.runtime.Symbol info) {
        errorMsg.error(info.left, message);
    }

    public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
        this();
        errorMsg=err;
        lexer=l;
    }
:};

scan with {: return lexer.nextToken(); :};

terminal String  ID;
terminal Integer DECIMAL_LITERAL;
terminal SEMICOLON, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK;
terminal PLUS, MINUS, TIMES, DIVIDE, MODULUS;
terminal EQ, NEQ, LT, LE, GT, GE;
terminal AND, OR, ASSIGN, ELIPSES;
terminal IF, ELSE, WHILE, DO, FOR, BREAK, CONTINUE, RETURN;
terminal VAR, FUN, TYPEDEF, STRUCT, UNION, ENUM;
terminal CONST, VOLATILE, EXTERN, STATIC, AUTO, REGISTER;
terminal VOID, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE;

non terminal Absyn.DecList      declaration_list;
non terminal Absyn.Dec          declaration;
non terminal ArrayList          bitfield_list;
non terminal ArrayList          parameter_list;
non terminal Absyn.Name        name;
non terminal Absyn.Ty          type;
non terminal Absyn.NameTy      type_name;
non terminal Absyn.Exp         expression;
non terminal Absyn.Exp         initialization ;
non terminal Absyn.ExpList     expression_list;
non terminal Absyn.FieldList   field_list;
non terminal Absyn.FieldList   parameters;
non terminal Absyn.FieldList   type_parameters;
non terminal Absyn.FieldVar    field_var;
non terminal Absyn.ForExp      for_statement;
non terminal Absyn.FunctionDec function_declaration;
non terminal Absyn.IfExp       if_statement;
non terminal Absyn.IntExp      integer_literal;
non terminal Absyn.LetExp      let_expression;
non terminal Absyn.NilExp      nil_expression;
non terminal Absyn.OpExp       operator_expression;
non terminal Absyn.RecordExp   record_expression;
non terminal Absyn.RecordTy    record_type;
non terminal Absyn.SeqExp      sequence_expression;
non terminal Absyn.SeqExp      compound_statement;
non terminal Absyn.SimpleVar   simple_variable;
non terminal Absyn.StringExp   string_literal;
non terminal Absyn.SubscriptVar array_subscript;
non terminal Absyn.TypeDec     type_declaration;
non terminal Absyn.Var         variable;
non terminal Absyn.VarDec      variable_declaration;
non terminal Absyn.VarExp      variable_expression;
non terminal Absyn.WhileExp    while_statement;
non terminal Absyn.BitfieldValue bitfield_value;
non terminal String struct_or_union;
non terminal Absyn.FieldList struct_or_union_declarator;
non terminal ArrayList enumerator_list;
non terminal String enumerator;
non terminal Absyn.Exp constant_expression;
non terminal Absyn.AssignExp assignment_expression;
non terminal Absyn.Exp initializer;
non terminal ArrayList initializer_list;
non terminal ArrayList struct_declaration_list;
non terminal ArrayList empty_array_type_list;
non terminal String empty_array_type;
non terminal ArrayList expression_array_type_list;
non terminal Absyn.Exp expression_array_type;
non terminal ArrayList pointer_list;
non terminal ArrayList brackets_list;
non terminal Absyn.Ty type_augments;
non terminal ArrayList parameter_type_list;
non terminal Absyn.CallExp function_call;

precedence nonassoc ELSE;
precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence nonassoc EQ, NEQ, LT, LE, GT, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULUS;

start with declaration_list;

declaration_list ::= declaration:d
    {: RESULT = new DeclarationList(d); :}
    | declaration_list:dl declaration:d
    {: dl.add(d); RESULT = dl; :}
    ;


declaration ::= VAR:v bitfield_list:b type:t name:n initialization:i SEMICOLON
    {: RESULT = new Absyn.VarDec(vleft, sym(n), t, i); :}
    | FUN:f bitfield_list:b type:t name:n parameters:p compound_statement:c
    {: RESULT = new Absyn.FunctionDec(fleft, sym(n), p, t, c); :}
    | FUN:f bitfield_list:b type:t name:n type_parameters:tp SEMICOLON
    {: RESULT = new Absyn.FunctionPrototype(fleft, sym(n), tp, t); :}
    | TYPEDEF:td type:t name:n SEMICOLON
    {: RESULT = new Absyn.TypeDef(tdleft, t, sym(n)); :}
    | struct_or_union:su name:n struct_or_union_declarator:d
    {: RESULT = new Absyn.StructDec(suleft, su, sym(n), d); :}
    | ENUM:e ID:i LBRACE enumerator_list:el RBRACE
    {: RESULT = new Absyn.EnumDec(eleft, sym(i), el); :}
    ;

bitfield_list ::=
    {: RESULT = new ArrayList<>(); :}
    | bitfield_value:v bitfield_list:l
    {: l.add(0, v);
       RESULT = l; :}
    ;

bitfield_value ::= CONST    {: RESULT = "const"; :}
    | VOLATILE             {: RESULT = "volatile"; :}
    | EXTERN              {: RESULT = "extern"; :}
    | STATIC              {: RESULT = "static"; :}
    | AUTO                {: RESULT = "auto"; :}
    | REGISTER            {: RESULT = "register"; :}
    ;

name ::= ID:i
    {: RESULT = i; :}
    ;

type ::= type_name:tn type_augments:ta
    {: RESULT = new Absyn.AugmentedType(tnleft, tn, ta); :}
    | type_name:tn
    {: RESULT = new Absyn.SimpleType(tnleft, tn); :}
    ;

type_name ::= VOID    {: RESULT = "void"; :}
    | CHAR           {: RESULT = "char"; :}
    | SHORT          {: RESULT = "short"; :}
    | INT            {: RESULT = "int"; :}
    | LONG           {: RESULT = "long"; :}
    | FLOAT          {: RESULT = "float"; :}
    | DOUBLE         {: RESULT = "double"; :}
    | ENUM ID:i      {: RESULT = "enum " + i; :}
    | ID:i           {: RESULT = i; :}
    ;

initialization ::=
    {: RESULT = null; :}
    | ASSIGN:a initializer:i
    {: RESULT = i; :}
    ;

type_augments ::= pointer_list:pl
    {: RESULT = new Absyn.PointerType(plleft, pl); :}
    | brackets_list:bl
    {: RESULT = new Absyn.ArrayType(blleft, bl); :}
    | pointer_list:pl brackets_list:bl
    {: RESULT = new Absyn.PointerArrayType(plleft, pl, bl); :}
    ;

pointer_list ::= TIMES:t
    {: ArrayList<Integer> list = new ArrayList<>();
       list.add(1);
       RESULT = list; :}
    | pointer_list:pl TIMES
    {: pl.add(1);
       RESULT = pl; :}
    ;

brackets_list ::= empty_array_type_list:el
    {: RESULT = el; :}
    | expression_array_type_list:el
    {: RESULT = el; :}
    ;

empty_array_type_list ::= empty_array_type:e
    {: ArrayList<String> list = new ArrayList<>();
       list.add(e);
       RESULT = list; :}
    | empty_array_type_list:el empty_array_type:e
    {: el.add(e);
       RESULT = el; :}
    ;

empty_array_type ::= LBRACK RBRACK
    {: RESULT = "[]"; :}
    ;

compound_statement ::= LBRACE expression_list:el RBRACE
    {: RESULT = new Absyn.SeqExp(elleft, el); :}
    | LBRACE RBRACE
    {: RESULT = new Absyn.SeqExp(eleft, null); :}
    ;

expression_list ::= expression:e
    {: RESULT = new Absyn.ExpList(e, null); :}
    | expression_list:el expression:e
    {: RESULT = new Absyn.ExpList(e, el); :}
    ;

expression_array_type_list ::= expression_array_type:e
    {: ArrayList<Absyn.Exp> list = new ArrayList<>();
       list.add(e);
       RESULT = list; :}
    | expression_array_type_list:el expression_array_type:e
    {: el.add(e);
       RESULT = el; :}
    ;

expression_array_type ::= LBRACK constant_expression:e RBRACK
    {: RESULT = e; :}
    ;

parameters ::= LPAREN parameter_list:pl RPAREN
    {: RESULT = pl; :}
    | LPAREN parameter_list:pl COMMA ELIPSES RPAREN
    {: RESULT = pl; :}
    | LPAREN RPAREN
    {: RESULT = new ArrayList<>(); :}
    ;

parameter_list ::= type:t name:n
    {: ArrayList<Absyn.Field> list = new ArrayList<>();
       list.add(new Absyn.Field(tleft, sym(n), t));
       RESULT = list; :}
    | parameter_list:pl COMMA type:t name:n
    {: pl.add(new Absyn.Field(tleft, sym(n), t));
       RESULT = pl; :}
    ;

type_parameters ::= LPAREN parameter_type_list:pl RPAREN
    {: RESULT = pl; :}
    | LPAREN parameter_type_list:pl COMMA ELIPSES RPAREN
    {: RESULT = pl; :}
    | LPAREN RPAREN
    {: RESULT = new ArrayList<>(); :}
    ;

parameter_type_list ::= type:t
    {: ArrayList<Absyn.Ty> list = new ArrayList<>();
       list.add(t);
       RESULT = list; :}
    | parameter_type_list:pl COMMA type:t
    {: pl.add(t);
       RESULT = pl; :}
    ;

initializer ::= assignment_expression:e
    {: RESULT = e; :}
    | LBRACE:l initializer_list:il RBRACE
    {: RESULT = new Absyn.ArrayExp(lleft, il); :}
    ;

initializer_list ::= initializer:i
    {: ArrayList<Absyn.Exp> list = new ArrayList<>();
       list.add(i);
       RESULT = list; :}
    | initializer_list:il COMMA initializer:i
    {: il.add(i);
       RESULT = il; :}
    ;

struct_or_union ::= STRUCT    {: RESULT = "struct"; :}
    | UNION               {: RESULT = "union"; :}
    ;

struct_or_union_declarator ::= LBRACE struct_declaration_list:sl RBRACE
    {: RESULT = sl; :}
    ;

struct_declaration_list ::= type:t name:n SEMICOLON
    {: ArrayList<Absyn.Field> list = new ArrayList<>();
       list.add(new Absyn.Field(tleft, sym(n), t));
       RESULT = list; :}
    | struct_declaration_list:sl type:t name:n SEMICOLON
    {: sl.add(new Absyn.Field(tleft, sym(n), t));
       RESULT = sl; :}
    ;

enumerator_list ::= enumerator:e
    {: ArrayList<String> list = new ArrayList<>();
       list.add(e);
       RESULT = list; :}
    | enumerator_list:el COMMA enumerator:e
    {: el.add(e);
       RESULT = el; :}
    ;

enumerator ::= ID:i
    {: RESULT = i; :}
    | ID:i ASSIGN constant_expression:e
    {: RESULT = i + "=" + e.toString(); :}
    ;

constant_expression ::= expression:e
    {: RESULT = e; :}
    ;

assignment_expression ::= variable:v ASSIGN expression:e
    {: RESULT = new Absyn.AssignExp(vleft, v, e); :}
    | expression:e
    {: RESULT = e; :}
    ;

expression ::= integer_literal:i
    {: RESULT = i; :}
    | string_literal:s
    {: RESULT = s; :}
    | variable:v
    {: RESULT = new Absyn.VarExp(vleft, v); :}
    | operator_expression:o
    {: RESULT = o; :}
    | function_call:f
    {: RESULT = f; :}
    | nil_expression:n
    {: RESULT = n; :}
    ;

operator_expression ::= expression:e1 PLUS:p expression:e2
    {: RESULT = new Absyn.OpExp(pleft, e1, Absyn.OpExp.PLUS, e2); :}
    | expression:e1 MINUS:m expression:e2
    {: RESULT = new Absyn.OpExp(mleft, e1, Absyn.OpExp.MINUS, e2); :}
    | expression:e1 TIMES:t expression:e2
    {: RESULT = new Absyn.OpExp(tleft, e1, Absyn.OpExp.TIMES, e2); :}
    | expression:e1 DIVIDE:d expression:e2
    {: RESULT = new Absyn.OpExp(dleft, e1, Absyn.OpExp.DIVIDE, e2); :}
    | expression:e1 MODULUS:m expression:e2
    {: RESULT = new Absyn.OpExp(mleft, e1, Absyn.OpExp.MOD, e2); :}
    ;

variable ::= simple_variable:v
    {: RESULT = v; :}
    | field_var:v
    {: RESULT = v; :}
    | array_subscript:v
    {: RESULT = v; :}
    ;

simple_variable ::= ID:i
    {: RESULT = new Absyn.SimpleVar(ileft, sym(i)); :}
    ;

integer_literal ::= DECIMAL_LITERAL:n
    {: RESULT = new Absyn.IntExp(nleft, n); :}
    ;

nil_expression ::=
    {: RESULT = new Absyn.NilExp(0); :}
    ;

function_call ::= ID:i LPAREN expression_list:el RPAREN
    {: RESULT = new Absyn.CallExp(ileft, sym(i), el); :}
    | ID:i LPAREN RPAREN
    {: RESULT = new Absyn.CallExp(ileft, sym(i), null); :}
    ;
