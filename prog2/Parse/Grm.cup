package Parse;
import ErrorMsg.ErrorMsg;
import Absyn.*;
import java.util.ArrayList;

parser code {:
    public ErrorMsg errorMsg;
    Lexer lexer;

    public void syntax_error(java_cup.runtime.Symbol current) {
        report_error("Syntax error (" + current.sym + ")", current);
    }

    public void report_error(String message, java_cup.runtime.Symbol info) {
        errorMsg.error(info.left, message);
    }

    public Grm(Lexer l, ErrorMsg e) {
        this();
        errorMsg = e;
        lexer = l;
    }
:};

action code {:
    static Symbol.Symbol sym(String s) {
        return Symbol.Symbol.symbol(s);
    }
:};

scan with {: return lexer.nextToken(); :};

/* Terminals */
terminal String ID, STRING_LITERAL;
terminal Integer DECIMAL_LITERAL;
terminal char CHAR_LITERAL;
terminal INT, COMMA, COLON, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK;
terminal LBRACE, RBRACE, PLUS, MINUS, TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE;
terminal AND, OR, ASSIGN, IF, ELSE, WHILE, FOR, DO, BREAK, FUN, VAR;
terminal VOLATILE, NOT, REGISTER, CONTINUE, TYPEDEF, STRUCT, STATIC, SIZEOF;
terminal RETURN, EXTERN, DOUBLE, UNION, SHORT, FLOAT, CONST, VOID, LONG;
terminal GOTO, ENUM, CHAR, AUTO, RSHIFTASSIGN, LSHIFTASSIGN, ELIPSES;
terminal BWISEORASSIGN, BWISEXORASSIGN, RSHIFT, LSHIFT, DIVASSIGN, ARROW;
terminal SUBASSIGN, DECREMENT, ADDASSIGN, INCREMENT, MULASSIGN;
terminal BWISEANDASSIGN, MODASSIGN, TILDE, BWISEOR, BWISEXOR, PERIOD;
terminal BITWISEAND, MODULUS;

/* Non terminals with types */
non terminal Absyn.Exp          Exp;
non terminal Absyn.Var          Var;
non terminal ArrayList          declaration_list;
non terminal Absyn.Dec          declaration;
non terminal ArrayList          bitfield_list;
non terminal Absyn.FieldVar bitfield_value;
non terminal Absyn.Ty           type;
non terminal Absyn.NameTy         name;
non terminal ArrayList          parameter_list;
non terminal ArrayList          type_parameters;
non terminal ArrayList          initializer_list;
non terminal ArrayList          enumerator_list;
non terminal ArrayList          struct_declaration_list;
non terminal ArrayList          empty_array_type_list;
non terminal ArrayList          expression_array_type_list;
non terminal ArrayList          pointer_list;

/* Precedence declarations */
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

/* Start with declaration_list */
start with declaration_list;

/* Grammar rules */
declaration_list ::=
    declaration:d
    {: ArrayList list = new ArrayList();
       list.add(d);
       RESULT = list; :}
  | declaration_list:dl declaration:d
    {: dl.add(d);
       RESULT = dl; :}
  ;


declaration ::=
    VAR bitfield_list:b type:t name:n SEMICOLON
    {: RESULT = new VarDec(VARleft, b, t, n, null); :}
  ;

bitfield_list ::=
    /* empty */
    {: RESULT = new ArrayList(); :}
  | bitfield_value:bv bitfield_list:bl
    {: bl.add(0, bv);
       RESULT = bl; :}
  ;

bitfield_value ::=
    CONST    {: RESULT = new BitfieldValue(CONSTleft, BitfieldValue.CONST); :}
  | VOLATILE {: RESULT = new BitfieldValue(VOLATILEleft, BitfieldValue.VOLATILE); :}
  | EXTERN   {: RESULT = new BitfieldValue(EXTERNleft, BitfieldValue.EXTERN); :}
  | STATIC   {: RESULT = new BitfieldValue(STATICleft, BitfieldValue.STATIC); :}
  | AUTO     {: RESULT = new BitfieldValue(AUTOleft, BitfieldValue.AUTO); :}
  | REGISTER {: RESULT = new BitfieldValue(REGISTERleft, BitfieldValue.REGISTER); :}
  ;

type ::=
    INT    {: RESULT = new Type(INTleft, Type.INT); :}
  | VOID   {: RESULT = new Type(VOIDleft, Type.VOID); :}
  | CHAR   {: RESULT = new Type(CHARleft, Type.CHAR); :}
  | SHORT  {: RESULT = new Type(SHORTleft, Type.SHORT); :}
  | LONG   {: RESULT = new Type(LONGleft, Type.LONG); :}
  | FLOAT  {: RESULT = new Type(FLOATleft, Type.FLOAT); :}
  | DOUBLE {: RESULT = new Type(DOUBLEleft, Type.DOUBLE); :}
  ;

name ::=
    ID:i
    {: RESULT = new Name(ileft, sym(i)); :}
  ;
