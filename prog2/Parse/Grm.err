Opening files...
Parsing specification from standard input...
Checking specification...
Warning: Terminal "CONTINUE" was declared but never used
Warning: Terminal "RETURN" was declared but never used
Warning: Terminal "BREAK" was declared but never used
Warning: Terminal "DO" was declared but never used
Warning: Non terminal "type_declaration" was declared but never used
Warning: Non terminal "let_expression" was declared but never used
Warning: Non terminal "field_list" was declared but never used
Warning: Non terminal "record_expression" was declared but never used
Warning: Non terminal "function_declaration" was declared but never used
Warning: Non terminal "variable_expression" was declared but never used
Warning: Non terminal "variable_declaration" was declared but never used
Warning: Non terminal "record_type" was declared but never used
Warning: Non terminal "sequence_expression" was declared but never used
Building parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...
  Filling in tables...
  Checking for non-reduced productions...
Writing parser...
===== Terminals =====
DIVIDE SHORT CHAR CONST GE 
DOUBLE LPAREN CONTINUE INT REGISTER 
FOR MINUS ELIPSES STATIC RPAREN 
SEMICOLON AND LT FUN OR 
COMMA EXTERN TYPEDEF PLUS ASSIGN 
IF ID LE EOF RETURN 
error AUTO NEQ BREAK VOID 
EQ LBRACK TIMES UNION LBRACE 
ELSE ENUM RBRACK WHILE FLOAT 
RBRACE MODULUS DECIMAL_LITERAL LONG VOLATILE 
STRUCT GT VAR DO 

===== Non terminals =====
simple_variable type_declaration let_expression struct_declaration_list bitfield_list 
declaration_list pointer_list initializer field_list enumerator 
$START record_expression function_declaration compound_statement initializer_list 
constant_expression variable_expression initialization struct_or_union for_statement 
name integer_literal variable_declaration if_statement expression_array_type_list 
operator_expression bitfield_value enumerator_list parameter_type_list expression 
type_parameters empty_array_type_list record_type brackets_list type_name 
expression_array_type empty_array_type parameter_list assignment_expression array_subscript 
type_augments variable while_statement field_var string_literal 
function_call sequence_expression parameters expression_list struct_or_union_declarator 
declaration nil_expression type 

===== Productions =====
function_call ::= ID LPAREN RPAREN 
function_call ::= ID LPAREN expression_list RPAREN 
nil_expression ::= VOID 
integer_literal ::= DECIMAL_LITERAL 
simple_variable ::= ID 
variable ::= array_subscript 
variable ::= field_var 
variable ::= simple_variable 
for_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression 
while_statement ::= WHILE LPAREN expression RPAREN expression 
if_statement ::= IF LPAREN expression RPAREN expression 
if_statement ::= IF LPAREN expression RPAREN expression ELSE expression 
operator_expression ::= expression OR expression 
operator_expression ::= expression AND expression 
operator_expression ::= expression GE expression 
operator_expression ::= expression GT expression 
operator_expression ::= expression LE expression 
operator_expression ::= expression LT expression 
operator_expression ::= expression NEQ expression 
operator_expression ::= expression EQ expression 
operator_expression ::= expression MODULUS expression 
operator_expression ::= expression DIVIDE expression 
operator_expression ::= expression TIMES expression 
operator_expression ::= expression MINUS expression 
operator_expression ::= expression PLUS expression 
expression ::= nil_expression 
expression ::= for_statement 
expression ::= while_statement 
expression ::= if_statement 
expression ::= function_call 
expression ::= operator_expression 
expression ::= variable 
expression ::= string_literal 
expression ::= integer_literal 
assignment_expression ::= expression 
assignment_expression ::= variable ASSIGN expression 
constant_expression ::= expression 
enumerator ::= ID ASSIGN constant_expression 
enumerator ::= ID 
enumerator_list ::= enumerator_list COMMA enumerator 
enumerator_list ::= enumerator 
struct_declaration_list ::= struct_declaration_list type name SEMICOLON 
struct_declaration_list ::= type name SEMICOLON 
struct_or_union_declarator ::= LBRACE struct_declaration_list RBRACE 
struct_or_union ::= UNION 
struct_or_union ::= STRUCT 
initializer_list ::= initializer_list COMMA initializer 
initializer_list ::= initializer 
initializer ::= LBRACE initializer_list RBRACE 
initializer ::= assignment_expression 
parameter_type_list ::= parameter_type_list COMMA type 
parameter_type_list ::= type 
type_parameters ::= LPAREN RPAREN 
type_parameters ::= LPAREN parameter_type_list COMMA ELIPSES RPAREN 
type_parameters ::= LPAREN parameter_type_list RPAREN 
parameter_list ::= parameter_list COMMA type name 
parameter_list ::= type name 
parameters ::= LPAREN RPAREN 
parameters ::= LPAREN parameter_list COMMA ELIPSES RPAREN 
parameters ::= LPAREN parameter_list RPAREN 
expression_array_type ::= LBRACK constant_expression RBRACK 
expression_array_type_list ::= expression_array_type_list expression_array_type 
expression_array_type_list ::= expression_array_type 
expression_list ::= expression_list expression 
expression_list ::= expression 
compound_statement ::= LBRACE RBRACE 
compound_statement ::= LBRACE expression_list RBRACE 
empty_array_type ::= LBRACK RBRACK 
empty_array_type_list ::= empty_array_type_list empty_array_type 
empty_array_type_list ::= empty_array_type 
brackets_list ::= expression_array_type_list 
brackets_list ::= empty_array_type_list 
pointer_list ::= pointer_list TIMES 
pointer_list ::= TIMES 
type_augments ::= pointer_list brackets_list 
type_augments ::= brackets_list 
type_augments ::= pointer_list 
initialization ::= ASSIGN initializer 
initialization ::= 
type_name ::= ID 
type_name ::= ENUM ID 
type_name ::= DOUBLE 
type_name ::= FLOAT 
type_name ::= LONG 
type_name ::= INT 
type_name ::= SHORT 
type_name ::= CHAR 
type_name ::= VOID 
type ::= type_name 
type ::= type_name type_augments 
name ::= ID 
bitfield_value ::= REGISTER 
bitfield_value ::= AUTO 
bitfield_value ::= STATIC 
bitfield_value ::= EXTERN 
bitfield_value ::= VOLATILE 
bitfield_value ::= CONST 
bitfield_list ::= bitfield_value bitfield_list 
bitfield_list ::= 
declaration ::= ENUM ID LBRACE enumerator_list RBRACE 
declaration ::= struct_or_union name struct_or_union_declarator 
declaration ::= TYPEDEF type name SEMICOLON 
declaration ::= FUN bitfield_list type name type_parameters SEMICOLON 
declaration ::= FUN bitfield_list type name parameters compound_statement 
declaration ::= VAR bitfield_list type name initialization SEMICOLON 
declaration_list ::= declaration_list declaration 
declaration_list ::= declaration 
$START ::= declaration_list EOF 

===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [struct_or_union ::= (*) UNION , {ID }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration_list ::= (*) declaration_list declaration , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [struct_or_union ::= (*) STRUCT , {ID }]
  [declaration ::= (*) struct_or_union name struct_or_union_declarator , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration_list ::= (*) declaration , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration ::= (*) TYPEDEF type name SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [$START ::= (*) declaration_list EOF , {EOF }]
}
transition on declaration_list to state [9]
transition on TYPEDEF to state [8]
transition on VAR to state [7]
transition on STRUCT to state [6]
transition on UNION to state [5]
transition on FUN to state [4]
transition on declaration to state [3]
transition on struct_or_union to state [2]
transition on ENUM to state [1]

-------------------
lalr_state [1]: {
  [declaration ::= ENUM (*) ID LBRACE enumerator_list RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on ID to state [179]

-------------------
lalr_state [2]: {
  [declaration ::= struct_or_union (*) name struct_or_union_declarator , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [name ::= (*) ID , {LBRACE }]
}
transition on name to state [168]
transition on ID to state [23]

-------------------
lalr_state [3]: {
  [declaration_list ::= declaration (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [4]: {
  [bitfield_value ::= (*) STATIC , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) CONST , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [declaration ::= FUN (*) bitfield_list type name type_parameters SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [bitfield_value ::= (*) REGISTER , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) EXTERN , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [declaration ::= FUN (*) bitfield_list type name parameters compound_statement , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [bitfield_value ::= (*) AUTO , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) VOLATILE , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_list ::= (*) , {ID ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}
transition on bitfield_value to state [121]
transition on EXTERN to state [120]
transition on AUTO to state [119]
transition on STATIC to state [118]
transition on bitfield_list to state [140]
transition on REGISTER to state [117]
transition on CONST to state [115]
transition on VOLATILE to state [114]

-------------------
lalr_state [5]: {
  [struct_or_union ::= UNION (*) , {ID }]
}

-------------------
lalr_state [6]: {
  [struct_or_union ::= STRUCT (*) , {ID }]
}

-------------------
lalr_state [7]: {
  [bitfield_value ::= (*) STATIC , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) CONST , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) REGISTER , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) EXTERN , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) AUTO , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) VOLATILE , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_list ::= (*) , {ID ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [declaration ::= VAR (*) bitfield_list type name initialization SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on bitfield_value to state [121]
transition on EXTERN to state [120]
transition on AUTO to state [119]
transition on STATIC to state [118]
transition on REGISTER to state [117]
transition on bitfield_list to state [116]
transition on CONST to state [115]
transition on VOLATILE to state [114]

-------------------
lalr_state [8]: {
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [declaration ::= TYPEDEF (*) type name SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
}
transition on SHORT to state [22]
transition on CHAR to state [21]
transition on FLOAT to state [20]
transition on type to state [19]
transition on ID to state [18]
transition on DOUBLE to state [17]
transition on VOID to state [16]
transition on LONG to state [15]
transition on type_name to state [14]
transition on INT to state [13]
transition on ENUM to state [12]

-------------------
lalr_state [9]: {
  [struct_or_union ::= (*) UNION , {ID }]
  [declaration ::= (*) ENUM ID LBRACE enumerator_list RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration_list ::= declaration_list (*) declaration , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration ::= (*) FUN bitfield_list type name type_parameters SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [struct_or_union ::= (*) STRUCT , {ID }]
  [declaration ::= (*) struct_or_union name struct_or_union_declarator , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration ::= (*) FUN bitfield_list type name parameters compound_statement , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration ::= (*) TYPEDEF type name SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [$START ::= declaration_list (*) EOF , {EOF }]
  [declaration ::= (*) VAR bitfield_list type name initialization SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on TYPEDEF to state [8]
transition on VAR to state [7]
transition on EOF to state [11]
transition on STRUCT to state [6]
transition on UNION to state [5]
transition on FUN to state [4]
transition on declaration to state [10]
transition on struct_or_union to state [2]
transition on ENUM to state [1]

-------------------
lalr_state [10]: {
  [declaration_list ::= declaration_list declaration (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [11]: {
  [$START ::= declaration_list EOF (*) , {EOF }]
}

-------------------
lalr_state [12]: {
  [type_name ::= ENUM (*) ID , {ID COMMA RPAREN LBRACK TIMES }]
}
transition on ID to state [113]

-------------------
lalr_state [13]: {
  [type_name ::= INT (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [14]: {
  [empty_array_type ::= (*) LBRACK RBRACK , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= (*) expression_array_type_list , {ID COMMA RPAREN }]
  [pointer_list ::= (*) TIMES , {ID COMMA RPAREN LBRACK TIMES }]
  [type_augments ::= (*) pointer_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type , {ID COMMA RPAREN LBRACK }]
  [type ::= type_name (*) , {ID COMMA RPAREN }]
  [empty_array_type_list ::= (*) empty_array_type_list empty_array_type , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= (*) empty_array_type_list , {ID COMMA RPAREN }]
  [type_augments ::= (*) pointer_list brackets_list , {ID COMMA RPAREN }]
  [expression_array_type ::= (*) LBRACK constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [type ::= type_name (*) type_augments , {ID COMMA RPAREN }]
  [empty_array_type_list ::= (*) empty_array_type , {ID COMMA RPAREN LBRACK }]
  [pointer_list ::= (*) pointer_list TIMES , {ID COMMA RPAREN LBRACK TIMES }]
  [type_augments ::= (*) brackets_list , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type_list expression_array_type , {ID COMMA RPAREN LBRACK }]
}
transition on LBRACK to state [34]
transition on TIMES to state [33]
transition on empty_array_type_list to state [32]
transition on expression_array_type_list to state [31]
transition on type_augments to state [30]
transition on brackets_list to state [29]
transition on expression_array_type to state [28]
transition on pointer_list to state [27]
transition on empty_array_type to state [26]

-------------------
lalr_state [15]: {
  [type_name ::= LONG (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [16]: {
  [type_name ::= VOID (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [17]: {
  [type_name ::= DOUBLE (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [18]: {
  [type_name ::= ID (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [19]: {
  [declaration ::= TYPEDEF type (*) name SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [name ::= (*) ID , {SEMICOLON }]
}
transition on name to state [24]
transition on ID to state [23]

-------------------
lalr_state [20]: {
  [type_name ::= FLOAT (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [21]: {
  [type_name ::= CHAR (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [22]: {
  [type_name ::= SHORT (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [23]: {
  [name ::= ID (*) , {SEMICOLON COMMA LPAREN RPAREN LBRACE ASSIGN }]
}

-------------------
lalr_state [24]: {
  [declaration ::= TYPEDEF type name (*) SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on SEMICOLON to state [25]

-------------------
lalr_state [25]: {
  [declaration ::= TYPEDEF type name SEMICOLON (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [26]: {
  [empty_array_type_list ::= empty_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [27]: {
  [empty_array_type ::= (*) LBRACK RBRACK , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= (*) expression_array_type_list , {ID COMMA RPAREN }]
  [type_augments ::= pointer_list (*) , {ID COMMA RPAREN }]
  [expression_array_type_list ::= (*) expression_array_type , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type_list empty_array_type , {ID COMMA RPAREN LBRACK }]
  [type_augments ::= pointer_list (*) brackets_list , {ID COMMA RPAREN }]
  [brackets_list ::= (*) empty_array_type_list , {ID COMMA RPAREN }]
  [expression_array_type ::= (*) LBRACK constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= (*) empty_array_type , {ID COMMA RPAREN LBRACK }]
  [pointer_list ::= pointer_list (*) TIMES , {ID COMMA RPAREN LBRACK TIMES }]
  [expression_array_type_list ::= (*) expression_array_type_list expression_array_type , {ID COMMA RPAREN LBRACK }]
}
transition on expression_array_type_list to state [31]
transition on TIMES to state [112]
transition on empty_array_type to state [26]
transition on LBRACK to state [34]
transition on expression_array_type to state [28]
transition on empty_array_type_list to state [32]
transition on brackets_list to state [111]

-------------------
lalr_state [28]: {
  [expression_array_type_list ::= expression_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [29]: {
  [type_augments ::= brackets_list (*) , {ID COMMA RPAREN }]
}

-------------------
lalr_state [30]: {
  [type ::= type_name type_augments (*) , {ID COMMA RPAREN }]
}

-------------------
lalr_state [31]: {
  [expression_array_type_list ::= expression_array_type_list (*) expression_array_type , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= expression_array_type_list (*) , {ID COMMA RPAREN }]
  [expression_array_type ::= (*) LBRACK constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on LBRACK to state [110]
transition on expression_array_type to state [109]

-------------------
lalr_state [32]: {
  [empty_array_type ::= (*) LBRACK RBRACK , {ID COMMA RPAREN LBRACK }]
  [empty_array_type_list ::= empty_array_type_list (*) empty_array_type , {ID COMMA RPAREN LBRACK }]
  [brackets_list ::= empty_array_type_list (*) , {ID COMMA RPAREN }]
}
transition on empty_array_type to state [108]
transition on LBRACK to state [107]

-------------------
lalr_state [33]: {
  [pointer_list ::= TIMES (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [34]: {
  [operator_expression ::= (*) expression DIVIDE expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) simple_variable , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LE expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [nil_expression ::= (*) VOID , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GT expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression_array_type ::= LBRACK (*) constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GE expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [constant_expression ::= (*) expression , {RBRACK }]
  [simple_variable ::= (*) ID , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression AND expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [empty_array_type ::= LBRACK (*) RBRACK , {ID COMMA RPAREN LBRACK }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on constant_expression to state [50]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [46]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]
transition on RBRACK to state [35]

-------------------
lalr_state [35]: {
  [empty_array_type ::= LBRACK RBRACK (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [36]: {
  [expression ::= integer_literal (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [37]: {
  [expression ::= if_statement (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [38]: {
  [while_statement ::= WHILE (*) LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on LPAREN to state [103]

-------------------
lalr_state [39]: {
  [integer_literal ::= DECIMAL_LITERAL (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [40]: {
  [expression ::= while_statement (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [41]: {
  [expression ::= function_call (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [42]: {
  [expression ::= nil_expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [43]: {
  [if_statement ::= IF (*) LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF (*) LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on LPAREN to state [97]

-------------------
lalr_state [44]: {
  [function_call ::= ID (*) LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= ID (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN IF ELSE WHILE FOR VOID }]
  [function_call ::= ID (*) LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on LPAREN to state [91]

-------------------
lalr_state [45]: {
  [expression ::= for_statement (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [46]: {
  [operator_expression ::= expression (*) DIVIDE expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) PLUS expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) AND expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [constant_expression ::= expression (*) , {COMMA RBRACE RBRACK }]
  [operator_expression ::= expression (*) LE expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) EQ expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) TIMES expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GE expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LT expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MODULUS expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MINUS expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) OR expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GT expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) NEQ expression , {COMMA RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [47]: {
  [expression ::= operator_expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [48]: {
  [variable ::= array_subscript (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [49]: {
  [expression ::= variable (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [50]: {
  [expression_array_type ::= LBRACK constant_expression (*) RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on RBRACK to state [90]

-------------------
lalr_state [51]: {
  [expression ::= string_literal (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [52]: {
  [for_statement ::= FOR (*) LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on LPAREN to state [56]

-------------------
lalr_state [53]: {
  [nil_expression ::= VOID (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [54]: {
  [variable ::= field_var (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [55]: {
  [variable ::= simple_variable (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [56]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) simple_variable , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [nil_expression ::= (*) VOID , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [simple_variable ::= (*) ID , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression DIVIDE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [for_statement ::= FOR LPAREN (*) expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [57]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [57]: {
  [operator_expression ::= expression (*) DIVIDE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) PLUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) AND expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) EQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) TIMES expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [for_statement ::= FOR LPAREN expression (*) SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MODULUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MINUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) OR expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) NEQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on SEMICOLON to state [68]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [58]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression MINUS (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [89]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [59]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression AND (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [88]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [60]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression MODULUS (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [87]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [61]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression DIVIDE (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [86]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [62]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression GE (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [85]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [63]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression NEQ (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [84]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [64]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression PLUS (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [83]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [65]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression EQ (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [82]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [66]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression LE (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [81]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [67]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression GT (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [80]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [68]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) simple_variable , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [nil_expression ::= (*) VOID , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [simple_variable ::= (*) ID , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression DIVIDE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [for_statement ::= FOR LPAREN expression SEMICOLON (*) expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression AND expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [75]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [69]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression TIMES (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [74]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [70]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression LT (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [73]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [71]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression OR (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [72]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [72]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression OR expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [73]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression LT expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [74]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression TIMES expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [75]: {
  [operator_expression ::= expression (*) DIVIDE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) PLUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) AND expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [for_statement ::= FOR LPAREN expression SEMICOLON expression (*) SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) TIMES expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MODULUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MINUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) OR expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) NEQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on SEMICOLON to state [76]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [76]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) simple_variable , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [nil_expression ::= (*) VOID , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [simple_variable ::= (*) ID , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [for_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON (*) expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression AND expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [77]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [77]: {
  [operator_expression ::= expression (*) DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) AND expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [for_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression (*) RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MODULUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) OR expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on RPAREN to state [78]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [78]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [for_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [79]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [79]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [for_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [80]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression GT expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [81]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression LE expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [82]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression EQ expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [83]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression PLUS expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [84]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression NEQ expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [85]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression GE expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [86]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression DIVIDE expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [87]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression MODULUS expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [88]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression AND expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [89]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression MINUS expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [90]: {
  [expression_array_type ::= LBRACK constant_expression RBRACK (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [91]: {
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [function_call ::= ID LPAREN (*) expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression_list ::= (*) expression , {ID DECIMAL_LITERAL RPAREN IF WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [function_call ::= ID LPAREN (*) RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression_list ::= (*) expression_list expression , {ID DECIMAL_LITERAL RPAREN IF WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression_list to state [94]
transition on expression to state [93]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on RPAREN to state [92]
transition on integer_literal to state [36]

-------------------
lalr_state [92]: {
  [function_call ::= ID LPAREN RPAREN (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [93]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression_list ::= expression (*) , {ID DECIMAL_LITERAL RPAREN RBRACE IF WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [94]: {
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [function_call ::= ID LPAREN expression_list (*) RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression_list ::= expression_list (*) expression , {ID DECIMAL_LITERAL RPAREN IF WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [96]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on RPAREN to state [95]
transition on integer_literal to state [36]

-------------------
lalr_state [95]: {
  [function_call ::= ID LPAREN expression_list RPAREN (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [96]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression_list ::= expression_list expression (*) , {ID DECIMAL_LITERAL RPAREN RBRACE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [97]: {
  [operator_expression ::= (*) expression DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) simple_variable , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= IF LPAREN (*) expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= IF LPAREN (*) expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [simple_variable ::= (*) ID , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression AND expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [98]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [98]: {
  [operator_expression ::= expression (*) DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= IF LPAREN expression (*) RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= IF LPAREN expression (*) RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MODULUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) OR expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on RPAREN to state [99]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [99]: {
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN (*) expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [100]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [100]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN expression (*) ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on ELSE to state [101]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [101]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN expression ELSE (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [102]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [102]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN expression ELSE expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [103]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) simple_variable , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [nil_expression ::= (*) VOID , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= WHILE LPAREN (*) expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [simple_variable ::= (*) ID , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression AND expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [104]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [104]: {
  [operator_expression ::= expression (*) DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) AND expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GE expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MODULUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= WHILE LPAREN expression (*) RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GT expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on RPAREN to state [105]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [105]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= WHILE LPAREN expression RPAREN (*) expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [106]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [106]: {
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) AND expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [while_statement ::= WHILE LPAREN expression RPAREN expression (*) , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MODULUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) OR expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL SEMICOLON COMMA RPAREN RBRACE RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF ELSE WHILE FOR VOID }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [107]: {
  [empty_array_type ::= LBRACK (*) RBRACK , {ID COMMA RPAREN LBRACK }]
}
transition on RBRACK to state [35]

-------------------
lalr_state [108]: {
  [empty_array_type_list ::= empty_array_type_list empty_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [109]: {
  [expression_array_type_list ::= expression_array_type_list expression_array_type (*) , {ID COMMA RPAREN LBRACK }]
}

-------------------
lalr_state [110]: {
  [operator_expression ::= (*) expression DIVIDE expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) simple_variable , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LE expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [nil_expression ::= (*) VOID , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GT expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression_array_type ::= LBRACK (*) constant_expression RBRACK , {ID COMMA RPAREN LBRACK }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GE expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [constant_expression ::= (*) expression , {RBRACK }]
  [simple_variable ::= (*) ID , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression AND expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {RBRACK PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on constant_expression to state [50]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [46]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [111]: {
  [type_augments ::= pointer_list brackets_list (*) , {ID COMMA RPAREN }]
}

-------------------
lalr_state [112]: {
  [pointer_list ::= pointer_list TIMES (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [113]: {
  [type_name ::= ENUM ID (*) , {ID COMMA RPAREN LBRACK TIMES }]
}

-------------------
lalr_state [114]: {
  [bitfield_value ::= VOLATILE (*) , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}

-------------------
lalr_state [115]: {
  [bitfield_value ::= CONST (*) , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}

-------------------
lalr_state [116]: {
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [declaration ::= VAR bitfield_list (*) type name initialization SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
}
transition on SHORT to state [22]
transition on CHAR to state [21]
transition on FLOAT to state [20]
transition on type to state [123]
transition on ID to state [18]
transition on DOUBLE to state [17]
transition on VOID to state [16]
transition on LONG to state [15]
transition on type_name to state [14]
transition on INT to state [13]
transition on ENUM to state [12]

-------------------
lalr_state [117]: {
  [bitfield_value ::= REGISTER (*) , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}

-------------------
lalr_state [118]: {
  [bitfield_value ::= STATIC (*) , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}

-------------------
lalr_state [119]: {
  [bitfield_value ::= AUTO (*) , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}

-------------------
lalr_state [120]: {
  [bitfield_value ::= EXTERN (*) , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}

-------------------
lalr_state [121]: {
  [bitfield_value ::= (*) STATIC , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) CONST , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) REGISTER , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_list ::= bitfield_value (*) bitfield_list , {ID ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) EXTERN , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) AUTO , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_value ::= (*) VOLATILE , {ID ENUM CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [bitfield_list ::= (*) , {ID ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}
transition on bitfield_value to state [121]
transition on EXTERN to state [120]
transition on AUTO to state [119]
transition on STATIC to state [118]
transition on REGISTER to state [117]
transition on bitfield_list to state [122]
transition on CONST to state [115]
transition on VOLATILE to state [114]

-------------------
lalr_state [122]: {
  [bitfield_list ::= bitfield_value bitfield_list (*) , {ID ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}

-------------------
lalr_state [123]: {
  [declaration ::= VAR bitfield_list type (*) name initialization SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [name ::= (*) ID , {SEMICOLON ASSIGN }]
}
transition on name to state [124]
transition on ID to state [23]

-------------------
lalr_state [124]: {
  [initialization ::= (*) ASSIGN initializer , {SEMICOLON }]
  [initialization ::= (*) , {SEMICOLON }]
  [declaration ::= VAR bitfield_list type name (*) initialization SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on ASSIGN to state [126]
transition on initialization to state [125]

-------------------
lalr_state [125]: {
  [declaration ::= VAR bitfield_list type name initialization (*) SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on SEMICOLON to state [139]

-------------------
lalr_state [126]: {
  [operator_expression ::= (*) expression DIVIDE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initializer ::= (*) LBRACE initializer_list RBRACE , {SEMICOLON }]
  [variable ::= (*) simple_variable , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression LE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= (*) expression , {SEMICOLON }]
  [nil_expression ::= (*) VOID , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression GT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression GE expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initialization ::= ASSIGN (*) initializer , {SEMICOLON }]
  [function_call ::= (*) ID LPAREN RPAREN , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [simple_variable ::= (*) ID , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression AND expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initializer ::= (*) assignment_expression , {SEMICOLON }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= (*) variable ASSIGN expression , {SEMICOLON }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {SEMICOLON PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on initializer to state [131]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [130]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [129]
transition on for_statement to state [45]
transition on ID to state [44]
transition on LBRACE to state [128]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on assignment_expression to state [127]
transition on integer_literal to state [36]

-------------------
lalr_state [127]: {
  [initializer ::= assignment_expression (*) , {SEMICOLON COMMA RBRACE }]
}

-------------------
lalr_state [128]: {
  [operator_expression ::= (*) expression DIVIDE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initializer ::= LBRACE (*) initializer_list RBRACE , {SEMICOLON COMMA RBRACE }]
  [initializer ::= (*) LBRACE initializer_list RBRACE , {COMMA RBRACE }]
  [variable ::= (*) simple_variable , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression LE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= (*) expression , {COMMA RBRACE }]
  [nil_expression ::= (*) VOID , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initializer_list ::= (*) initializer , {COMMA RBRACE }]
  [variable ::= (*) field_var , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression GT expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initializer_list ::= (*) initializer_list COMMA initializer , {COMMA RBRACE }]
  [variable ::= (*) array_subscript , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression GE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [simple_variable ::= (*) ID , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression AND expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initializer ::= (*) assignment_expression , {COMMA RBRACE }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= (*) variable ASSIGN expression , {COMMA RBRACE }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on initializer to state [135]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [130]
transition on array_subscript to state [48]
transition on initializer_list to state [134]
transition on operator_expression to state [47]
transition on expression to state [129]
transition on for_statement to state [45]
transition on ID to state [44]
transition on LBRACE to state [128]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on assignment_expression to state [127]
transition on integer_literal to state [36]

-------------------
lalr_state [129]: {
  [operator_expression ::= expression (*) DIVIDE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) PLUS expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) AND expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) EQ expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) TIMES expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= expression (*) , {SEMICOLON COMMA RBRACE }]
  [operator_expression ::= expression (*) GE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LT expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MODULUS expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MINUS expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) OR expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GT expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) NEQ expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [130]: {
  [expression ::= variable (*) , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= variable (*) ASSIGN expression , {SEMICOLON COMMA RBRACE }]
}
transition on ASSIGN to state [132]

-------------------
lalr_state [131]: {
  [initialization ::= ASSIGN initializer (*) , {SEMICOLON }]
}

-------------------
lalr_state [132]: {
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= variable ASSIGN (*) expression , {SEMICOLON COMMA RBRACE }]
  [expression ::= (*) operator_expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GT expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) simple_variable , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [nil_expression ::= (*) VOID , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [simple_variable ::= (*) ID , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression DIVIDE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression AND expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [133]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [133]: {
  [operator_expression ::= expression (*) DIVIDE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) PLUS expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) AND expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) EQ expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) TIMES expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GE expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) LT expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MODULUS expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) MINUS expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= variable ASSIGN expression (*) , {SEMICOLON COMMA RBRACE }]
  [operator_expression ::= expression (*) OR expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) GT expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= expression (*) NEQ expression , {SEMICOLON COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on OR to state [71]
transition on LT to state [70]
transition on TIMES to state [69]
transition on GT to state [67]
transition on LE to state [66]
transition on EQ to state [65]
transition on PLUS to state [64]
transition on NEQ to state [63]
transition on GE to state [62]
transition on DIVIDE to state [61]
transition on MODULUS to state [60]
transition on AND to state [59]
transition on MINUS to state [58]

-------------------
lalr_state [134]: {
  [initializer ::= LBRACE initializer_list (*) RBRACE , {SEMICOLON COMMA RBRACE }]
  [initializer_list ::= initializer_list (*) COMMA initializer , {COMMA RBRACE }]
}
transition on RBRACE to state [137]
transition on COMMA to state [136]

-------------------
lalr_state [135]: {
  [initializer_list ::= initializer (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [136]: {
  [operator_expression ::= (*) expression DIVIDE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initializer ::= (*) LBRACE initializer_list RBRACE , {COMMA RBRACE }]
  [variable ::= (*) simple_variable , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression LE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= (*) expression , {COMMA RBRACE }]
  [nil_expression ::= (*) VOID , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression GT expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) if_statement , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initializer_list ::= initializer_list COMMA (*) initializer , {COMMA RBRACE }]
  [variable ::= (*) array_subscript , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression GE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [simple_variable ::= (*) ID , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR ASSIGN }]
  [operator_expression ::= (*) expression AND expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [initializer ::= (*) assignment_expression , {COMMA RBRACE }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [assignment_expression ::= (*) variable ASSIGN expression , {COMMA RBRACE }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on initializer to state [138]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [130]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [129]
transition on for_statement to state [45]
transition on ID to state [44]
transition on LBRACE to state [128]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on assignment_expression to state [127]
transition on integer_literal to state [36]

-------------------
lalr_state [137]: {
  [initializer ::= LBRACE initializer_list RBRACE (*) , {SEMICOLON COMMA RBRACE }]
}

-------------------
lalr_state [138]: {
  [initializer_list ::= initializer_list COMMA initializer (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [139]: {
  [declaration ::= VAR bitfield_list type name initialization SEMICOLON (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [140]: {
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [declaration ::= FUN bitfield_list (*) type name type_parameters SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [declaration ::= FUN bitfield_list (*) type name parameters compound_statement , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
}
transition on SHORT to state [22]
transition on FLOAT to state [20]
transition on CHAR to state [21]
transition on type to state [141]
transition on ID to state [18]
transition on DOUBLE to state [17]
transition on VOID to state [16]
transition on LONG to state [15]
transition on type_name to state [14]
transition on INT to state [13]
transition on ENUM to state [12]

-------------------
lalr_state [141]: {
  [declaration ::= FUN bitfield_list type (*) name parameters compound_statement , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [name ::= (*) ID , {LPAREN }]
  [declaration ::= FUN bitfield_list type (*) name type_parameters SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on name to state [142]
transition on ID to state [23]

-------------------
lalr_state [142]: {
  [parameters ::= (*) LPAREN parameter_list COMMA ELIPSES RPAREN , {LBRACE }]
  [declaration ::= FUN bitfield_list type name (*) parameters compound_statement , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [type_parameters ::= (*) LPAREN parameter_type_list COMMA ELIPSES RPAREN , {SEMICOLON }]
  [parameters ::= (*) LPAREN parameter_list RPAREN , {LBRACE }]
  [type_parameters ::= (*) LPAREN parameter_type_list RPAREN , {SEMICOLON }]
  [parameters ::= (*) LPAREN RPAREN , {LBRACE }]
  [declaration ::= FUN bitfield_list type name (*) type_parameters SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [type_parameters ::= (*) LPAREN RPAREN , {SEMICOLON }]
}
transition on LPAREN to state [145]
transition on parameters to state [144]
transition on type_parameters to state [143]

-------------------
lalr_state [143]: {
  [declaration ::= FUN bitfield_list type name type_parameters (*) SEMICOLON , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on SEMICOLON to state [167]

-------------------
lalr_state [144]: {
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [declaration ::= FUN bitfield_list type name parameters (*) compound_statement , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [compound_statement ::= (*) LBRACE RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on compound_statement to state [163]
transition on LBRACE to state [162]

-------------------
lalr_state [145]: {
  [parameter_list ::= (*) parameter_list COMMA type name , {COMMA RPAREN }]
  [parameter_type_list ::= (*) parameter_type_list COMMA type , {COMMA RPAREN }]
  [type_name ::= (*) VOID , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID COMMA RPAREN LBRACK TIMES }]
  [parameters ::= LPAREN (*) RPAREN , {LBRACE }]
  [type_parameters ::= LPAREN (*) RPAREN , {SEMICOLON }]
  [type ::= (*) type_name type_augments , {ID COMMA RPAREN }]
  [type_name ::= (*) INT , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) ID , {ID COMMA RPAREN LBRACK TIMES }]
  [parameters ::= LPAREN (*) parameter_list RPAREN , {LBRACE }]
  [type_parameters ::= LPAREN (*) parameter_type_list RPAREN , {SEMICOLON }]
  [type_name ::= (*) CHAR , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) DOUBLE , {ID COMMA RPAREN LBRACK TIMES }]
  [parameter_list ::= (*) type name , {COMMA RPAREN }]
  [parameter_type_list ::= (*) type , {COMMA RPAREN }]
  [type ::= (*) type_name , {ID COMMA RPAREN }]
  [type_name ::= (*) LONG , {ID COMMA RPAREN LBRACK TIMES }]
  [parameters ::= LPAREN (*) parameter_list COMMA ELIPSES RPAREN , {LBRACE }]
  [type_parameters ::= LPAREN (*) parameter_type_list COMMA ELIPSES RPAREN , {SEMICOLON }]
  [type_name ::= (*) SHORT , {ID COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) ENUM ID , {ID COMMA RPAREN LBRACK TIMES }]
}
transition on parameter_list to state [149]
transition on FLOAT to state [20]
transition on CHAR to state [21]
transition on SHORT to state [22]
transition on parameter_type_list to state [148]
transition on RPAREN to state [147]
transition on type to state [146]
transition on ID to state [18]
transition on DOUBLE to state [17]
transition on VOID to state [16]
transition on LONG to state [15]
transition on type_name to state [14]
transition on INT to state [13]
transition on ENUM to state [12]

-------------------
lalr_state [146]: {
  [parameter_list ::= type (*) name , {COMMA RPAREN }]
  [parameter_type_list ::= type (*) , {COMMA RPAREN }]
  [name ::= (*) ID , {COMMA RPAREN }]
}
transition on name to state [161]
transition on ID to state [23]

-------------------
lalr_state [147]: {
  [parameters ::= LPAREN RPAREN (*) , {LBRACE }]
  [type_parameters ::= LPAREN RPAREN (*) , {SEMICOLON }]
}

-------------------
lalr_state [148]: {
  [type_parameters ::= LPAREN parameter_type_list (*) COMMA ELIPSES RPAREN , {SEMICOLON }]
  [parameter_type_list ::= parameter_type_list (*) COMMA type , {COMMA RPAREN }]
  [type_parameters ::= LPAREN parameter_type_list (*) RPAREN , {SEMICOLON }]
}
transition on RPAREN to state [157]
transition on COMMA to state [156]

-------------------
lalr_state [149]: {
  [parameters ::= LPAREN parameter_list (*) RPAREN , {LBRACE }]
  [parameters ::= LPAREN parameter_list (*) COMMA ELIPSES RPAREN , {LBRACE }]
  [parameter_list ::= parameter_list (*) COMMA type name , {COMMA RPAREN }]
}
transition on RPAREN to state [151]
transition on COMMA to state [150]

-------------------
lalr_state [150]: {
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [parameters ::= LPAREN parameter_list COMMA (*) ELIPSES RPAREN , {LBRACE }]
  [parameter_list ::= parameter_list COMMA (*) type name , {COMMA RPAREN }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
}
transition on SHORT to state [22]
transition on CHAR to state [21]
transition on FLOAT to state [20]
transition on ELIPSES to state [153]
transition on type to state [152]
transition on ID to state [18]
transition on DOUBLE to state [17]
transition on VOID to state [16]
transition on LONG to state [15]
transition on type_name to state [14]
transition on INT to state [13]
transition on ENUM to state [12]

-------------------
lalr_state [151]: {
  [parameters ::= LPAREN parameter_list RPAREN (*) , {LBRACE }]
}

-------------------
lalr_state [152]: {
  [name ::= (*) ID , {COMMA RPAREN }]
  [parameter_list ::= parameter_list COMMA type (*) name , {COMMA RPAREN }]
}
transition on name to state [155]
transition on ID to state [23]

-------------------
lalr_state [153]: {
  [parameters ::= LPAREN parameter_list COMMA ELIPSES (*) RPAREN , {LBRACE }]
}
transition on RPAREN to state [154]

-------------------
lalr_state [154]: {
  [parameters ::= LPAREN parameter_list COMMA ELIPSES RPAREN (*) , {LBRACE }]
}

-------------------
lalr_state [155]: {
  [parameter_list ::= parameter_list COMMA type name (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [156]: {
  [type_name ::= (*) VOID , {COMMA RPAREN LBRACK TIMES }]
  [type_parameters ::= LPAREN parameter_type_list COMMA (*) ELIPSES RPAREN , {SEMICOLON }]
  [parameter_type_list ::= parameter_type_list COMMA (*) type , {COMMA RPAREN }]
  [type_name ::= (*) ID , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) SHORT , {COMMA RPAREN LBRACK TIMES }]
  [type ::= (*) type_name , {COMMA RPAREN }]
  [type_name ::= (*) ENUM ID , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) LONG , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) CHAR , {COMMA RPAREN LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {COMMA RPAREN }]
  [type_name ::= (*) DOUBLE , {COMMA RPAREN LBRACK TIMES }]
  [type_name ::= (*) INT , {COMMA RPAREN LBRACK TIMES }]
}
transition on SHORT to state [22]
transition on FLOAT to state [20]
transition on CHAR to state [21]
transition on ELIPSES to state [159]
transition on type to state [158]
transition on ID to state [18]
transition on DOUBLE to state [17]
transition on VOID to state [16]
transition on LONG to state [15]
transition on type_name to state [14]
transition on INT to state [13]
transition on ENUM to state [12]

-------------------
lalr_state [157]: {
  [type_parameters ::= LPAREN parameter_type_list RPAREN (*) , {SEMICOLON }]
}

-------------------
lalr_state [158]: {
  [parameter_type_list ::= parameter_type_list COMMA type (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [159]: {
  [type_parameters ::= LPAREN parameter_type_list COMMA ELIPSES (*) RPAREN , {SEMICOLON }]
}
transition on RPAREN to state [160]

-------------------
lalr_state [160]: {
  [type_parameters ::= LPAREN parameter_type_list COMMA ELIPSES RPAREN (*) , {SEMICOLON }]
}

-------------------
lalr_state [161]: {
  [parameter_list ::= type name (*) , {COMMA RPAREN }]
}

-------------------
lalr_state [162]: {
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [compound_statement ::= LBRACE (*) expression_list RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [compound_statement ::= LBRACE (*) RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression_list ::= (*) expression , {ID DECIMAL_LITERAL RBRACE IF WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression_list ::= (*) expression_list expression , {ID DECIMAL_LITERAL RBRACE IF WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression_list to state [165]
transition on expression to state [93]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on RBRACE to state [164]
transition on integer_literal to state [36]

-------------------
lalr_state [163]: {
  [declaration ::= FUN bitfield_list type name parameters compound_statement (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [164]: {
  [compound_statement ::= LBRACE RBRACE (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [165]: {
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [compound_statement ::= LBRACE expression_list (*) RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MODULUS expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression_list ::= expression_list (*) expression , {ID DECIMAL_LITERAL RBRACE IF WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression AND expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) variable , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression OR expression , {ID DECIMAL_LITERAL RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR IF WHILE FOR VOID }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [96]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on RBRACE to state [166]
transition on integer_literal to state [36]

-------------------
lalr_state [166]: {
  [compound_statement ::= LBRACE expression_list RBRACE (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [167]: {
  [declaration ::= FUN bitfield_list type name type_parameters SEMICOLON (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [168]: {
  [declaration ::= struct_or_union name (*) struct_or_union_declarator , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [struct_or_union_declarator ::= (*) LBRACE struct_declaration_list RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on struct_or_union_declarator to state [170]
transition on LBRACE to state [169]

-------------------
lalr_state [169]: {
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [struct_declaration_list ::= (*) struct_declaration_list type name SEMICOLON , {ID RBRACE ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [struct_declaration_list ::= (*) type name SEMICOLON , {ID RBRACE ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [struct_or_union_declarator ::= LBRACE (*) struct_declaration_list RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
}
transition on SHORT to state [22]
transition on FLOAT to state [20]
transition on CHAR to state [21]
transition on type to state [172]
transition on ID to state [18]
transition on DOUBLE to state [17]
transition on struct_declaration_list to state [171]
transition on VOID to state [16]
transition on LONG to state [15]
transition on type_name to state [14]
transition on INT to state [13]
transition on ENUM to state [12]

-------------------
lalr_state [170]: {
  [declaration ::= struct_or_union name struct_or_union_declarator (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [171]: {
  [type_name ::= (*) VOID , {ID LBRACK TIMES }]
  [type_name ::= (*) ID , {ID LBRACK TIMES }]
  [type_name ::= (*) FLOAT , {ID LBRACK TIMES }]
  [type_name ::= (*) SHORT , {ID LBRACK TIMES }]
  [type ::= (*) type_name , {ID }]
  [type_name ::= (*) ENUM ID , {ID LBRACK TIMES }]
  [struct_or_union_declarator ::= LBRACE struct_declaration_list (*) RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [type_name ::= (*) LONG , {ID LBRACK TIMES }]
  [type_name ::= (*) CHAR , {ID LBRACK TIMES }]
  [type ::= (*) type_name type_augments , {ID }]
  [type_name ::= (*) DOUBLE , {ID LBRACK TIMES }]
  [type_name ::= (*) INT , {ID LBRACK TIMES }]
  [struct_declaration_list ::= struct_declaration_list (*) type name SEMICOLON , {ID RBRACE ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}
transition on SHORT to state [22]
transition on FLOAT to state [20]
transition on CHAR to state [21]
transition on RBRACE to state [176]
transition on type to state [175]
transition on ID to state [18]
transition on DOUBLE to state [17]
transition on VOID to state [16]
transition on LONG to state [15]
transition on type_name to state [14]
transition on INT to state [13]
transition on ENUM to state [12]

-------------------
lalr_state [172]: {
  [struct_declaration_list ::= type (*) name SEMICOLON , {ID RBRACE ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
  [name ::= (*) ID , {SEMICOLON }]
}
transition on name to state [173]
transition on ID to state [23]

-------------------
lalr_state [173]: {
  [struct_declaration_list ::= type name (*) SEMICOLON , {ID RBRACE ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}
transition on SEMICOLON to state [174]

-------------------
lalr_state [174]: {
  [struct_declaration_list ::= type name SEMICOLON (*) , {ID RBRACE ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}

-------------------
lalr_state [175]: {
  [name ::= (*) ID , {SEMICOLON }]
  [struct_declaration_list ::= struct_declaration_list type (*) name SEMICOLON , {ID RBRACE ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}
transition on name to state [177]
transition on ID to state [23]

-------------------
lalr_state [176]: {
  [struct_or_union_declarator ::= LBRACE struct_declaration_list RBRACE (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [177]: {
  [struct_declaration_list ::= struct_declaration_list type name (*) SEMICOLON , {ID RBRACE ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}
transition on SEMICOLON to state [178]

-------------------
lalr_state [178]: {
  [struct_declaration_list ::= struct_declaration_list type name SEMICOLON (*) , {ID RBRACE ENUM VOID CHAR SHORT INT LONG FLOAT DOUBLE }]
}

-------------------
lalr_state [179]: {
  [declaration ::= ENUM ID (*) LBRACE enumerator_list RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on LBRACE to state [180]

-------------------
lalr_state [180]: {
  [enumerator_list ::= (*) enumerator_list COMMA enumerator , {COMMA RBRACE }]
  [enumerator ::= (*) ID ASSIGN constant_expression , {COMMA RBRACE }]
  [enumerator_list ::= (*) enumerator , {COMMA RBRACE }]
  [declaration ::= ENUM ID LBRACE (*) enumerator_list RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
  [enumerator ::= (*) ID , {COMMA RBRACE }]
}
transition on enumerator to state [183]
transition on enumerator_list to state [182]
transition on ID to state [181]

-------------------
lalr_state [181]: {
  [enumerator ::= ID (*) ASSIGN constant_expression , {COMMA RBRACE }]
  [enumerator ::= ID (*) , {COMMA RBRACE }]
}
transition on ASSIGN to state [187]

-------------------
lalr_state [182]: {
  [enumerator_list ::= enumerator_list (*) COMMA enumerator , {COMMA RBRACE }]
  [declaration ::= ENUM ID LBRACE enumerator_list (*) RBRACE , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}
transition on RBRACE to state [185]
transition on COMMA to state [184]

-------------------
lalr_state [183]: {
  [enumerator_list ::= enumerator (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [184]: {
  [enumerator_list ::= enumerator_list COMMA (*) enumerator , {COMMA RBRACE }]
  [enumerator ::= (*) ID ASSIGN constant_expression , {COMMA RBRACE }]
  [enumerator ::= (*) ID , {COMMA RBRACE }]
}
transition on enumerator to state [186]
transition on ID to state [181]

-------------------
lalr_state [185]: {
  [declaration ::= ENUM ID LBRACE enumerator_list RBRACE (*) , {EOF VAR FUN TYPEDEF STRUCT UNION ENUM }]
}

-------------------
lalr_state [186]: {
  [enumerator_list ::= enumerator_list COMMA enumerator (*) , {COMMA RBRACE }]
}

-------------------
lalr_state [187]: {
  [operator_expression ::= (*) expression DIVIDE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) operator_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) simple_variable , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) nil_expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [nil_expression ::= (*) VOID , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MODULUS expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) function_call , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) field_var , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GT expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression PLUS expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) integer_literal , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression EQ expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [enumerator ::= ID ASSIGN (*) constant_expression , {COMMA RBRACE }]
  [expression ::= (*) if_statement , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [variable ::= (*) array_subscript , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression GE expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression MINUS expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) string_literal , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [function_call ::= (*) ID LPAREN RPAREN , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression NEQ expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) while_statement , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [constant_expression ::= (*) expression , {COMMA RBRACE }]
  [simple_variable ::= (*) ID , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression AND expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression TIMES expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) variable , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [for_statement ::= (*) FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression LT expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [expression ::= (*) for_statement , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
  [operator_expression ::= (*) expression OR expression , {COMMA RBRACE PLUS MINUS TIMES DIVIDE MODULUS EQ NEQ LT LE GT GE AND OR }]
}
transition on simple_variable to state [55]
transition on field_var to state [54]
transition on VOID to state [53]
transition on FOR to state [52]
transition on string_literal to state [51]
transition on constant_expression to state [188]
transition on variable to state [49]
transition on array_subscript to state [48]
transition on operator_expression to state [47]
transition on expression to state [46]
transition on for_statement to state [45]
transition on ID to state [44]
transition on IF to state [43]
transition on nil_expression to state [42]
transition on function_call to state [41]
transition on while_statement to state [40]
transition on DECIMAL_LITERAL to state [39]
transition on WHILE to state [38]
transition on if_statement to state [37]
transition on integer_literal to state [36]

-------------------
lalr_state [188]: {
  [enumerator ::= ID ASSIGN constant_expression (*) , {COMMA RBRACE }]
}

-------------------
Closing files...
------- CUP v0.10g Parser Generation Summary -------
  0 errors and 13 warnings
  54 terminals, 53 non terminals, and 108 productions declared, 
  producing 189 unique parse states.
  13 terminals declared but not used.
  0 non terminals declared but not used.
  0 productions never reduced.
  0 conflicts detected (3 expected).
  Code written to "Grm.java", and "sym.java".
---------------------------------------------------- (v0.10g)
