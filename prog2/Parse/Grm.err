Opening files...
Parsing specification from standard input...
Checking specification...
Warning: Terminal "SHORT" was declared but never used
Warning: Terminal "DOUBLE" was declared but never used
Warning: Terminal "CONTINUE" was declared but never used
Warning: Terminal "ELIPSES" was declared but never used
Warning: Terminal "AND" was declared but never used
Warning: Terminal "OR" was declared but never used
Warning: Terminal "TYPEDEF" was declared but never used
Warning: Terminal "RETURN" was declared but never used
Warning: Terminal "BREAK" was declared but never used
Warning: Terminal "ENUM" was declared but never used
Warning: Terminal "FLOAT" was declared but never used
Warning: Terminal "MODULUS" was declared but never used
Warning: Terminal "LONG" was declared but never used
Warning: Terminal "DO" was declared but never used
Warning: Non terminal "let_expression" was declared but never used
Warning: Non terminal "field_list" was declared but never used
Warning: Non terminal "record_expression" was declared but never used
Warning: Non terminal "name" was declared but never used
Warning: Non terminal "type_parameters" was declared but never used
Building parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...
  Filling in tables...
  Checking for non-reduced productions...
*** Production "enumerator ::= ID ASSIGN expression " never reduced
*** Production "enumerator ::= ID " never reduced
*** Production "empty_array_type ::= LBRACK RBRACK " never reduced
*** Production "struct_or_union ::= UNION " never reduced
*** Production "struct_or_union ::= STRUCT " never reduced
*** Production "enumerator_list ::= enumerator_list COMMA enumerator " never reduced
*** Production "enumerator_list ::= enumerator " never reduced
*** Production "parameter_type_list ::= parameter_type_list COMMA type_name " never reduced
*** Production "parameter_type_list ::= type_name " never reduced
*** Production "brackets_list ::= expression_array_type_list " never reduced
*** Production "brackets_list ::= empty_array_type_list " never reduced
*** Production "pointer_list ::= pointer_list TIMES " never reduced
*** Production "pointer_list ::= TIMES " never reduced
*** Production "expression_array_type_list ::= expression_array_type_list expression " never reduced
*** Production "expression_array_type_list ::= expression " never reduced
*** Production "empty_array_type_list ::= empty_array_type_list empty_array_type " never reduced
*** Production "empty_array_type_list ::= empty_array_type " never reduced
*** Production "struct_declaration_list ::= struct_declaration_list type_name ID SEMICOLON " never reduced
*** Production "struct_declaration_list ::= type_name ID SEMICOLON " never reduced
*** Production "initializer_list ::= initializer_list COMMA expression " never reduced
*** Production "initializer_list ::= expression " never reduced
*** Production "parameter_list ::= parameter_list COMMA type_name ID " never reduced
*** Production "parameter_list ::= type_name ID " never reduced
Writing parser...
===== Terminals =====
DIVIDE SHORT CHAR CONST GE 
DOUBLE CONTINUE LPAREN INT REGISTER 
FOR MINUS ELIPSES STATIC RPAREN 
SEMICOLON AND LT FUN OR 
COMMA EXTERN TYPEDEF PLUS ASSIGN 
IF DOT ID LE EOF 
RETURN error AUTO NEQ BREAK 
VOID EQ LBRACK TIMES UNION 
LBRACE ELSE ENUM RBRACK TO 
WHILE FLOAT RBRACE MODULUS DECIMAL_LITERAL 
LONG VOLATILE STRUCT GT VAR 
DO 

===== Non terminals =====
simple_variable let_expression bitfield_list struct_declaration_list declaration_list 
pointer_list field_list enumerator $START record_expression 
compound_statement initializer_list variable_expression initialization struct_or_union 
for_statement name integer_literal if_statement expression_array_type_list 
operator_expression bitfield_value enumerator_list expression parameter_type_list 
type_parameters empty_array_type_list brackets_list type_name empty_array_type 
parameter_list array_subscript variable while_statement field_var 
string_literal function_call parameters expression_list declaration 
nil_expression 

===== Productions =====
array_subscript ::= variable LBRACK expression RBRACK 
field_var ::= variable DOT ID 
for_statement ::= FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression 
while_statement ::= WHILE LPAREN expression RPAREN expression 
if_statement ::= IF LPAREN expression RPAREN expression 
if_statement ::= IF LPAREN expression RPAREN expression ELSE expression 
function_call ::= ID LPAREN RPAREN 
function_call ::= ID LPAREN expression_list RPAREN 
nil_expression ::= VOID 
integer_literal ::= DECIMAL_LITERAL 
variable_expression ::= variable 
simple_variable ::= ID 
variable ::= array_subscript 
variable ::= field_var 
variable ::= simple_variable 
expression_list ::= expression_list expression 
expression_list ::= expression 
compound_statement ::= LBRACE RBRACE 
compound_statement ::= LBRACE expression_list RBRACE 
operator_expression ::= expression GE expression 
operator_expression ::= expression GT expression 
operator_expression ::= expression LE expression 
operator_expression ::= expression LT expression 
operator_expression ::= expression NEQ expression 
operator_expression ::= expression EQ expression 
operator_expression ::= expression DIVIDE expression 
operator_expression ::= expression TIMES expression 
operator_expression ::= expression MINUS expression 
operator_expression ::= expression PLUS expression 
expression ::= nil_expression 
expression ::= compound_statement 
expression ::= for_statement 
expression ::= while_statement 
expression ::= if_statement 
expression ::= function_call 
expression ::= operator_expression 
expression ::= variable_expression 
expression ::= string_literal 
expression ::= integer_literal 
enumerator ::= ID ASSIGN expression 
enumerator ::= ID 
empty_array_type ::= LBRACK RBRACK 
struct_or_union ::= UNION 
struct_or_union ::= STRUCT 
bitfield_value ::= REGISTER 
bitfield_value ::= AUTO 
bitfield_value ::= STATIC 
bitfield_value ::= EXTERN 
bitfield_value ::= VOLATILE 
bitfield_value ::= CONST 
type_name ::= ID 
type_name ::= INT 
type_name ::= CHAR 
type_name ::= VOID 
enumerator_list ::= enumerator_list COMMA enumerator 
enumerator_list ::= enumerator 
parameter_type_list ::= parameter_type_list COMMA type_name 
parameter_type_list ::= type_name 
brackets_list ::= expression_array_type_list 
brackets_list ::= empty_array_type_list 
pointer_list ::= pointer_list TIMES 
pointer_list ::= TIMES 
expression_array_type_list ::= expression_array_type_list expression 
expression_array_type_list ::= expression 
empty_array_type_list ::= empty_array_type_list empty_array_type 
empty_array_type_list ::= empty_array_type 
struct_declaration_list ::= struct_declaration_list type_name ID SEMICOLON 
struct_declaration_list ::= type_name ID SEMICOLON 
initializer_list ::= initializer_list COMMA expression 
initializer_list ::= expression 
bitfield_list ::= bitfield_value bitfield_list 
bitfield_list ::= 
parameter_list ::= parameter_list COMMA type_name ID 
parameter_list ::= type_name ID 
declaration ::= FUN bitfield_list type_name ID parameters compound_statement 
declaration ::= VAR bitfield_list type_name ID initialization SEMICOLON 
declaration_list ::= declaration_list declaration 
declaration_list ::= declaration 
$START ::= declaration_list EOF 

===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [declaration_list ::= (*) declaration_list declaration , {EOF VAR FUN }]
  [declaration ::= (*) FUN bitfield_list type_name ID parameters compound_statement , {EOF VAR FUN }]
  [declaration_list ::= (*) declaration , {EOF VAR FUN }]
  [declaration ::= (*) VAR bitfield_list type_name ID initialization SEMICOLON , {EOF VAR FUN }]
  [$START ::= (*) declaration_list EOF , {EOF }]
}
transition on declaration to state [4]
transition on FUN to state [3]
transition on declaration_list to state [2]
transition on VAR to state [1]

-------------------
lalr_state [1]: {
  [bitfield_value ::= (*) REGISTER , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_value ::= (*) EXTERN , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID VOID CHAR INT }]
  [bitfield_value ::= (*) AUTO , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_list ::= (*) , {ID VOID CHAR INT }]
  [bitfield_value ::= (*) VOLATILE , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_value ::= (*) STATIC , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [declaration ::= VAR (*) bitfield_list type_name ID initialization SEMICOLON , {EOF VAR FUN }]
  [bitfield_value ::= (*) CONST , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
}
transition on bitfield_value to state [12]
transition on EXTERN to state [11]
transition on AUTO to state [10]
transition on REGISTER to state [9]
transition on STATIC to state [7]
transition on bitfield_list to state [98]
transition on VOLATILE to state [6]
transition on CONST to state [5]

-------------------
lalr_state [2]: {
  [declaration_list ::= declaration_list (*) declaration , {EOF VAR FUN }]
  [declaration ::= (*) FUN bitfield_list type_name ID parameters compound_statement , {EOF VAR FUN }]
  [declaration ::= (*) VAR bitfield_list type_name ID initialization SEMICOLON , {EOF VAR FUN }]
  [$START ::= declaration_list (*) EOF , {EOF }]
}
transition on declaration to state [97]
transition on FUN to state [3]
transition on EOF to state [96]
transition on VAR to state [1]

-------------------
lalr_state [3]: {
  [bitfield_value ::= (*) REGISTER , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_value ::= (*) EXTERN , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID VOID CHAR INT }]
  [bitfield_value ::= (*) AUTO , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [declaration ::= FUN (*) bitfield_list type_name ID parameters compound_statement , {EOF VAR FUN }]
  [bitfield_list ::= (*) , {ID VOID CHAR INT }]
  [bitfield_value ::= (*) VOLATILE , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_value ::= (*) STATIC , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_value ::= (*) CONST , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
}
transition on bitfield_value to state [12]
transition on EXTERN to state [11]
transition on AUTO to state [10]
transition on REGISTER to state [9]
transition on bitfield_list to state [8]
transition on STATIC to state [7]
transition on VOLATILE to state [6]
transition on CONST to state [5]

-------------------
lalr_state [4]: {
  [declaration_list ::= declaration (*) , {EOF VAR FUN }]
}

-------------------
lalr_state [5]: {
  [bitfield_value ::= CONST (*) , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
}

-------------------
lalr_state [6]: {
  [bitfield_value ::= VOLATILE (*) , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
}

-------------------
lalr_state [7]: {
  [bitfield_value ::= STATIC (*) , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
}

-------------------
lalr_state [8]: {
  [type_name ::= (*) INT , {ID }]
  [declaration ::= FUN bitfield_list (*) type_name ID parameters compound_statement , {EOF VAR FUN }]
  [type_name ::= (*) CHAR , {ID }]
  [type_name ::= (*) ID , {ID }]
  [type_name ::= (*) VOID , {ID }]
}
transition on INT to state [18]
transition on CHAR to state [17]
transition on VOID to state [16]
transition on type_name to state [15]
transition on ID to state [14]

-------------------
lalr_state [9]: {
  [bitfield_value ::= REGISTER (*) , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
}

-------------------
lalr_state [10]: {
  [bitfield_value ::= AUTO (*) , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
}

-------------------
lalr_state [11]: {
  [bitfield_value ::= EXTERN (*) , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
}

-------------------
lalr_state [12]: {
  [bitfield_list ::= bitfield_value (*) bitfield_list , {ID VOID CHAR INT }]
  [bitfield_value ::= (*) REGISTER , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_value ::= (*) EXTERN , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_list ::= (*) bitfield_value bitfield_list , {ID VOID CHAR INT }]
  [bitfield_value ::= (*) AUTO , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_list ::= (*) , {ID VOID CHAR INT }]
  [bitfield_value ::= (*) VOLATILE , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_value ::= (*) STATIC , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
  [bitfield_value ::= (*) CONST , {ID CONST VOLATILE EXTERN STATIC AUTO REGISTER VOID CHAR INT }]
}
transition on bitfield_value to state [12]
transition on EXTERN to state [11]
transition on AUTO to state [10]
transition on bitfield_list to state [13]
transition on REGISTER to state [9]
transition on STATIC to state [7]
transition on VOLATILE to state [6]
transition on CONST to state [5]

-------------------
lalr_state [13]: {
  [bitfield_list ::= bitfield_value bitfield_list (*) , {ID VOID CHAR INT }]
}

-------------------
lalr_state [14]: {
  [type_name ::= ID (*) , {ID }]
}

-------------------
lalr_state [15]: {
  [declaration ::= FUN bitfield_list type_name (*) ID parameters compound_statement , {EOF VAR FUN }]
}
transition on ID to state [19]

-------------------
lalr_state [16]: {
  [type_name ::= VOID (*) , {ID }]
}

-------------------
lalr_state [17]: {
  [type_name ::= CHAR (*) , {ID }]
}

-------------------
lalr_state [18]: {
  [type_name ::= INT (*) , {ID }]
}

-------------------
lalr_state [19]: {
  [declaration ::= FUN bitfield_list type_name ID (*) parameters compound_statement , {EOF VAR FUN }]
}
transition on parameters to state [20]

-------------------
lalr_state [20]: {
  [declaration ::= FUN bitfield_list type_name ID parameters (*) compound_statement , {EOF VAR FUN }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {EOF VAR FUN }]
  [compound_statement ::= (*) LBRACE RBRACE , {EOF VAR FUN }]
}
transition on compound_statement to state [22]
transition on LBRACE to state [21]

-------------------
lalr_state [21]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= LBRACE (*) expression_list RBRACE , {EOF ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VAR FUN VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= LBRACE (*) RBRACE , {EOF ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VAR FUN VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression_list ::= (*) expression , {ID DECIMAL_LITERAL LBRACE RBRACE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression_list ::= (*) expression_list expression , {ID DECIMAL_LITERAL LBRACE RBRACE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression_list to state [36]
transition on expression to state [35]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on RBRACE to state [24]
transition on integer_literal to state [23]

-------------------
lalr_state [22]: {
  [declaration ::= FUN bitfield_list type_name ID parameters compound_statement (*) , {EOF VAR FUN }]
}

-------------------
lalr_state [23]: {
  [expression ::= integer_literal (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [24]: {
  [compound_statement ::= LBRACE RBRACE (*) , {EOF ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VAR FUN VOID }]
}

-------------------
lalr_state [25]: {
  [expression ::= if_statement (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [26]: {
  [while_statement ::= WHILE (*) LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LPAREN to state [92]

-------------------
lalr_state [27]: {
  [integer_literal ::= DECIMAL_LITERAL (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [28]: {
  [expression ::= while_statement (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [29]: {
  [expression ::= function_call (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [30]: {
  [expression ::= nil_expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [31]: {
  [if_statement ::= IF (*) LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF (*) LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LPAREN to state [86]

-------------------
lalr_state [32]: {
  [expression ::= compound_statement (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [33]: {
  [function_call ::= ID (*) LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= ID (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= ID (*) LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LPAREN to state [82]

-------------------
lalr_state [34]: {
  [expression ::= for_statement (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [35]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression_list ::= expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [36]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= LBRACE expression_list (*) RBRACE , {EOF ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VAR FUN VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL LBRACE RBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression_list ::= expression_list (*) expression , {ID DECIMAL_LITERAL LBRACE RBRACE IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [81]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on RBRACE to state [80]
transition on integer_literal to state [23]

-------------------
lalr_state [37]: {
  [expression ::= variable_expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [38]: {
  [expression ::= operator_expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [39]: {
  [variable ::= array_subscript (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [40]: {
  [variable_expression ::= variable (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= variable (*) LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [field_var ::= variable (*) DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on DOT to state [76]
transition on LBRACK to state [75]

-------------------
lalr_state [41]: {
  [expression ::= string_literal (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [42]: {
  [for_statement ::= FOR (*) LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LPAREN to state [46]

-------------------
lalr_state [43]: {
  [nil_expression ::= VOID (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [44]: {
  [variable ::= field_var (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [45]: {
  [variable ::= simple_variable (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [46]: {
  [for_statement ::= FOR LPAREN (*) VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on VAR to state [47]

-------------------
lalr_state [47]: {
  [for_statement ::= FOR LPAREN VAR (*) ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on ID to state [48]

-------------------
lalr_state [48]: {
  [for_statement ::= FOR LPAREN VAR ID (*) ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on ASSIGN to state [49]

-------------------
lalr_state [49]: {
  [field_var ::= (*) variable DOT ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [variable_expression ::= (*) variable , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression GE expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression PLUS expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) string_literal , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [variable ::= (*) simple_variable , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression NEQ expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) while_statement , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression MINUS expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) variable_expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [variable ::= (*) field_var , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression LT expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) for_statement , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [nil_expression ::= (*) VOID , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [compound_statement ::= (*) LBRACE RBRACE , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression TIMES expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) operator_expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [variable ::= (*) array_subscript , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression LE expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) compound_statement , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression DIVIDE expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) function_call , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [for_statement ::= FOR LPAREN VAR ID ASSIGN (*) expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [simple_variable ::= (*) ID , {LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression GT expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) nil_expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) integer_literal , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [function_call ::= (*) ID LPAREN RPAREN , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= (*) expression EQ expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [expression ::= (*) if_statement , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [50]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [50]: {
  [operator_expression ::= expression (*) LE expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= expression (*) EQ expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= expression (*) MINUS expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [for_statement ::= FOR LPAREN VAR ID ASSIGN expression (*) TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= expression (*) LT expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= expression (*) DIVIDE expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= expression (*) PLUS expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= expression (*) GT expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= expression (*) NEQ expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
  [operator_expression ::= expression (*) TIMES expression , {PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on TO to state [54]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [51]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression MINUS (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [74]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [52]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression DIVIDE (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [73]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [53]: {
  [operator_expression ::= expression GE (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [72]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [54]: {
  [field_var ::= (*) variable DOT ID , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable_expression ::= (*) variable , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression GE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) string_literal , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) simple_variable , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) while_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) variable_expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) field_var , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression LT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) for_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [nil_expression ::= (*) VOID , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [compound_statement ::= (*) LBRACE RBRACE , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) operator_expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) array_subscript , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression LE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) compound_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) function_call , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [for_statement ::= FOR LPAREN VAR ID ASSIGN expression TO (*) expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [simple_variable ::= (*) ID , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression GT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) nil_expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) integer_literal , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [function_call ::= (*) ID LPAREN RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) if_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [69]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [55]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression NEQ (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [68]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [56]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression PLUS (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [67]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [57]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression EQ (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [66]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [58]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression LE (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [65]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [59]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression GT (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [64]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [60]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression TIMES (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [63]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [61]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression LT (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [62]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [62]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression LT expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [63]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression TIMES expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [64]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression GT expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [65]: {
  [operator_expression ::= expression LE expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [66]: {
  [operator_expression ::= expression EQ expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [67]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression PLUS expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [68]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression NEQ expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [69]: {
  [operator_expression ::= expression (*) LE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [for_statement ::= FOR LPAREN VAR ID ASSIGN expression TO expression (*) RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) GE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) LT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) GT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on RPAREN to state [70]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [70]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [71]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [71]: {
  [for_statement ::= FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [72]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression GE expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [73]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression DIVIDE expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [74]: {
  [operator_expression ::= expression MINUS expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [75]: {
  [field_var ::= (*) variable DOT ID , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable_expression ::= (*) variable , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression GE expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression PLUS expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) string_literal , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) simple_variable , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression NEQ expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) while_statement , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [array_subscript ::= variable LBRACK (*) expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression MINUS expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) variable_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) field_var , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression LT expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) for_statement , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [nil_expression ::= (*) VOID , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [compound_statement ::= (*) LBRACE RBRACE , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression TIMES expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) operator_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) array_subscript , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression LE expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) compound_statement , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression DIVIDE expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) function_call , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [simple_variable ::= (*) ID , {LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression GT expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) nil_expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) integer_literal , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [function_call ::= (*) ID LPAREN RPAREN , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression EQ expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) if_statement , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [78]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [76]: {
  [field_var ::= variable DOT (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on ID to state [77]

-------------------
lalr_state [77]: {
  [field_var ::= variable DOT ID (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [78]: {
  [operator_expression ::= expression (*) LE expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) EQ expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) MINUS expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) GE expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) LT expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) DIVIDE expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) PLUS expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [array_subscript ::= variable LBRACK expression (*) RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) NEQ expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) TIMES expression , {RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on RBRACK to state [79]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [79]: {
  [array_subscript ::= variable LBRACK expression RBRACK (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [80]: {
  [compound_statement ::= LBRACE expression_list RBRACE (*) , {EOF ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VAR FUN VOID }]
}

-------------------
lalr_state [81]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression_list ::= expression_list expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE IF WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [82]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [function_call ::= ID LPAREN (*) expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression_list ::= (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [function_call ::= ID LPAREN (*) RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression_list ::= (*) expression_list expression , {ID DECIMAL_LITERAL RPAREN LBRACE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression_list to state [84]
transition on expression to state [35]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on RPAREN to state [83]
transition on integer_literal to state [23]

-------------------
lalr_state [83]: {
  [function_call ::= ID LPAREN RPAREN (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [84]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [function_call ::= ID LPAREN expression_list (*) RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression_list ::= expression_list (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE IF WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE IF WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [81]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on RPAREN to state [85]
transition on integer_literal to state [23]

-------------------
lalr_state [85]: {
  [function_call ::= ID LPAREN expression_list RPAREN (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}

-------------------
lalr_state [86]: {
  [field_var ::= (*) variable DOT ID , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable_expression ::= (*) variable , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression GE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) string_literal , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= IF LPAREN (*) expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) simple_variable , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) while_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) variable_expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= IF LPAREN (*) expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) field_var , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression LT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) for_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [nil_expression ::= (*) VOID , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [compound_statement ::= (*) LBRACE RBRACE , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) operator_expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) array_subscript , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression LE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) compound_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) function_call , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [simple_variable ::= (*) ID , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression GT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) nil_expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) integer_literal , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [function_call ::= (*) ID LPAREN RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) if_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [87]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [87]: {
  [operator_expression ::= expression (*) LE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= IF LPAREN expression (*) RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) GE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) LT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= IF LPAREN expression (*) RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) GT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on RPAREN to state [88]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [88]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN (*) expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [89]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [89]: {
  [if_statement ::= IF LPAREN expression RPAREN expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN expression (*) ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on ELSE to state [90]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [90]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN expression ELSE (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [91]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [91]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= IF LPAREN expression RPAREN expression ELSE expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [92]: {
  [field_var ::= (*) variable DOT ID , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable_expression ::= (*) variable , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression GE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) string_literal , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) simple_variable , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) while_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) variable_expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) field_var , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression LT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) for_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [nil_expression ::= (*) VOID , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [compound_statement ::= (*) LBRACE RBRACE , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) operator_expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [while_statement ::= WHILE LPAREN (*) expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [variable ::= (*) array_subscript , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression LE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) compound_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) function_call , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [simple_variable ::= (*) ID , {RPAREN LBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression GT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) nil_expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) integer_literal , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [function_call ::= (*) ID LPAREN RPAREN , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= (*) expression EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [expression ::= (*) if_statement , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [93]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [93]: {
  [operator_expression ::= expression (*) LE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) EQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) MINUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) GE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) LT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) DIVIDE expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) PLUS expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) GT expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [while_statement ::= WHILE LPAREN expression (*) RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
  [operator_expression ::= expression (*) TIMES expression , {RPAREN PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on RPAREN to state [94]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [94]: {
  [field_var ::= (*) variable DOT ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable_expression ::= (*) variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) string_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression ELSE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) simple_variable , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) while_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [array_subscript ::= (*) variable LBRACK expression RBRACK , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [integer_literal ::= (*) DECIMAL_LITERAL , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE expression_list RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) variable_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [if_statement ::= (*) IF LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) field_var , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) for_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [nil_expression ::= (*) VOID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [compound_statement ::= (*) LBRACE RBRACE , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) operator_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= WHILE LPAREN expression RPAREN (*) expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= (*) WHILE LPAREN expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [variable ::= (*) array_subscript , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) compound_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN expression_list RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) function_call , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [for_statement ::= (*) FOR LPAREN VAR ID ASSIGN expression TO expression RPAREN expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [simple_variable ::= (*) ID , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE LBRACK RBRACK DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) nil_expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) integer_literal , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [function_call ::= (*) ID LPAREN RPAREN , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= (*) expression EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [expression ::= (*) if_statement , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on simple_variable to state [45]
transition on field_var to state [44]
transition on VOID to state [43]
transition on FOR to state [42]
transition on string_literal to state [41]
transition on variable to state [40]
transition on array_subscript to state [39]
transition on operator_expression to state [38]
transition on variable_expression to state [37]
transition on expression to state [95]
transition on for_statement to state [34]
transition on ID to state [33]
transition on LBRACE to state [21]
transition on compound_statement to state [32]
transition on IF to state [31]
transition on nil_expression to state [30]
transition on function_call to state [29]
transition on while_statement to state [28]
transition on DECIMAL_LITERAL to state [27]
transition on WHILE to state [26]
transition on if_statement to state [25]
transition on integer_literal to state [23]

-------------------
lalr_state [95]: {
  [operator_expression ::= expression (*) LE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) EQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) MINUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) LT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) DIVIDE expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) PLUS expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [while_statement ::= WHILE LPAREN expression RPAREN expression (*) , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) GT expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) NEQ expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
  [operator_expression ::= expression (*) TIMES expression , {ID DECIMAL_LITERAL RPAREN LBRACE RBRACE RBRACK PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE TO IF ELSE WHILE FOR VOID }]
}
transition on LT to state [61]
transition on TIMES to state [60]
transition on GT to state [59]
transition on LE to state [58]
transition on EQ to state [57]
transition on PLUS to state [56]
transition on NEQ to state [55]
transition on GE to state [53]
transition on DIVIDE to state [52]
transition on MINUS to state [51]

-------------------
lalr_state [96]: {
  [$START ::= declaration_list EOF (*) , {EOF }]
}

-------------------
lalr_state [97]: {
  [declaration_list ::= declaration_list declaration (*) , {EOF VAR FUN }]
}

-------------------
lalr_state [98]: {
  [type_name ::= (*) INT , {ID }]
  [type_name ::= (*) CHAR , {ID }]
  [declaration ::= VAR bitfield_list (*) type_name ID initialization SEMICOLON , {EOF VAR FUN }]
  [type_name ::= (*) ID , {ID }]
  [type_name ::= (*) VOID , {ID }]
}
transition on INT to state [18]
transition on CHAR to state [17]
transition on VOID to state [16]
transition on type_name to state [99]
transition on ID to state [14]

-------------------
lalr_state [99]: {
  [declaration ::= VAR bitfield_list type_name (*) ID initialization SEMICOLON , {EOF VAR FUN }]
}
transition on ID to state [100]

-------------------
lalr_state [100]: {
  [declaration ::= VAR bitfield_list type_name ID (*) initialization SEMICOLON , {EOF VAR FUN }]
}
transition on initialization to state [101]

-------------------
lalr_state [101]: {
  [declaration ::= VAR bitfield_list type_name ID initialization (*) SEMICOLON , {EOF VAR FUN }]
}
transition on SEMICOLON to state [102]

-------------------
lalr_state [102]: {
  [declaration ::= VAR bitfield_list type_name ID initialization SEMICOLON (*) , {EOF VAR FUN }]
}

-------------------
Closing files...
------- CUP v0.10g Parser Generation Summary -------
  0 errors and 42 warnings
  56 terminals, 41 non terminals, and 79 productions declared, 
  producing 103 unique parse states.
  19 terminals declared but not used.
  0 non terminals declared but not used.
  0 productions never reduced.
  0 conflicts detected (3 expected).
  Code written to "Grm.java", and "sym.java".
---------------------------------------------------- (v0.10g)
